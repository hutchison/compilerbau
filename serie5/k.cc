/* translation of file(s)
	"abstract.k"
	"unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_TYPES

#include "k.h"
#include <stdio.h>
#include <ctype.h>
#include <cstring>
#include <sys/types.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma warning( disable : 4786 )
#endif
#include <new>
#include <set>
#include <list>
#include <algorithm>

#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \
&& !defined(DONT_USE_HASHSET)
#  define USE_HASHSET
#endif
#ifdef USE_HASHSET
#  if defined(__GNUC__) && __GNUC__>2
#    include <ext/hash_set>
#  else
#    include <hash_set>
#  endif
#endif

using namespace std;

namespace kc {

inline bool
ht_less(casestring p1, casestring p2){
    return kc_strcmp(p1->name, p2->name)<0;
}

inline bool
ht_less(nocasestring p1, nocasestring p2){
    return kc_strcasecmp(p1->name, p2->name)<0;
}

inline bool
ht_less(real p1, real p2){
    return p1->value < p2->value;
}

inline bool
ht_less(integer p1, integer p2){
    return p1->value < p2->value;
}

inline bool
ht_less(voidptr p1, voidptr p2){
    return p1->pointer < p2->pointer;
}

bool
ht_less(abstract_phylum p1, abstract_phylum p2)
{
    enum_operators prod_sel=p1->prod_sel();
    enum_operators prod_sel2=p2->prod_sel();
    if(prod_sel<prod_sel2)
	return true;
    if(prod_sel>prod_sel2)
	return false;
    switch(prod_sel) {
	case sel_NoCaseStr:
	    return ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));
	case sel__Str:
	    return ht_less(static_cast<casestring>(p1),static_cast<casestring>(p2));
	case sel__Real:
	    return ht_less(static_cast<real>(p1),static_cast<real>(p2));
	case sel__Int:
	    return ht_less(static_cast<integer>(p1),static_cast<integer>(p2));
	case sel__VoidPtr:
	    return ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));
	default: {
	    int i=0;
	    bool still_unique = kc_storageclass_still_uniq[phylum_info[p1->phylum()].uniq_stored];
	    abstract_phylum sub1=0;
	    do {
		sub1=p1->subphylum(i);
		abstract_phylum sub2=p2->subphylum(i);
		if(still_unique) {
		    if(sub1<sub2)
			return true;
		    if(sub2<sub1)
			return false;
		}
		else {
		    if(ht_less(sub1, sub2))
			return true;
		    if(ht_less(sub2, sub1))
			return false;
		}
		++i;
	    } while(sub1);
	}
    }
    return false;
}

template<typename T>
class phylum_less : std::binary_function<T, T, bool>
{
    public:
    bool operator()(const T& X, const T& Y) const
	{ return ht_less(X,Y); }
};

inline void deletefun(c_abstract_phylum t){
    delete const_cast<abstract_phylum>(t);
}


#ifdef USE_HASHSET
struct hashitem {
    size_t hashvalue;
    casestring contents;
    hashitem(casestring cs): contents(cs) {
	unsigned long h = 0;
	kc_char_t const *s = cs->name;
	for ( ; *s; ++s)
	    h = 5*h + *s;
	hashvalue=(size_t)h;
    }
};

inline void deletefunhashitem(hashitem t) {
    delete t.contents;
}

#  ifdef __GNUC__
struct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) == 0; } };

struct hash_hashitem { size_t operator()(hashitem hi) const {
	return hi.hashvalue; } };

#  else
struct comp_hashitem {
    enum { bucket_size = 4, min_buckets = 8 };
    // bucket_size and min_buckets are just guesses
    size_t operator()(const hashitem hi) const {
	return hi.hashvalue; }
    bool operator()(const hashitem hi1, const hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }
};
#  endif // Whether gcc or icc
#endif // Whether hash or not

struct hashtable_level
{
    hashtable_level(bool cod = true): clean_on_destruction(cod) { }
    void clear(bool free_entries=true) {
	if(free_entries)
	    clear_entries();
	_casestring.clear();
	_nocasestring.clear();
	_integer.clear();
	_real.clear();
	_voidptr.clear();
	_abstract_phylum.clear();
    }
    void clear_entries() {
#ifdef USE_HASHSET
	std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);
#else
	std::for_each(_casestring.begin(),_casestring.end(),deletefun);
#endif
	std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);
	std::for_each(_integer.begin(),_integer.end(),deletefun);
	std::for_each(_real.begin(),_real.end(),deletefun);
	std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);
	std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletefun);
    }
    ~hashtable_level() {
	clear(clean_on_destruction);
    }
    abstract_phylum check_insert(abstract_phylum t) {
	return *_abstract_phylum.insert(t).first;
    }
    casestring check_insert(casestring t) {
#ifdef USE_HASHSET
	return (*_casestring.insert(hashitem(t)).first).contents;
#else
	return *_casestring.insert(t).first;
#endif
    }
    nocasestring check_insert(nocasestring t) {
	return *_nocasestring.insert(t).first;
    }
    integer check_insert(integer t) {
	return *_integer.insert(t).first;
    }
    real check_insert(real t) {
	return *_real.insert(t).first;
    }
    voidptr check_insert(voidptr t) {
	return *_voidptr.insert(t).first;
    }
private:
    bool clean_on_destruction;
#ifdef USE_HASHSET
#  ifdef __GNUC__
#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)
    std::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    else
    __gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    endif
#  else
    std::hash_set<hashitem, comp_hashitem> _casestring;
#  endif
#else
    std::set<casestring, phylum_less<casestring> > _casestring;
#endif
    std::set<nocasestring, phylum_less<nocasestring> > _nocasestring;
    std::set<integer, phylum_less<integer> > _integer;
    std::set<real, phylum_less<real> > _real;
    std::set<voidptr, phylum_less<voidptr> > _voidptr;
    std::set<abstract_phylum, phylum_less<abstract_phylum> > _abstract_phylum;
};

class hashtable_stack: public std::list<hashtable_level> {
public:
    hashtable_stack(): _pos(begin()) { }

    void inc_level() { _pos=insert(_pos, hashtable_level()); }
    void dec_level() { if(valid() && _pos!=end()) ++_pos; }
    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }

    bool valid() const { return !empty(); }
    hashtable_level& get_level() { return *_pos; }

    template<typename T>
    T check_insert(T t) {
	return dynamic_cast<T>((*_pos).check_insert(t));
    }
private:
    iterator _pos;
};

class hashtable_struct_t {
public:
    // don't clean _static_level on destruction (program ends)
    hashtable_struct_t(): _static_level(false), _to_be_freed(false),  _dynamic(false) { }

    template <typename T>
    T ht_check_insert(T t) {
	if(_dynamic && _dynamic_level.valid())
	    return _dynamic_level.check_insert(t);
	else
	    return dynamic_cast<T>(_static_level.check_insert(t));
    }
    void ht_static() {_dynamic=false; }
    void ht_dynamic() {
	_dynamic=true;
	if(!_dynamic_level.valid())
	    _dynamic_level.inc_level();
    }
    void ht_inc_level() { _dynamic_level.inc_level(); }
    void ht_dec_level() { _dynamic_level.dec_level(); }
    void ht_free_level() { _dynamic_level.free_level(); }
    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }

    bool to_be_freed() { return _to_be_freed; }
    void set_to_be_freed(bool b=true) { _to_be_freed=b; }
private:
    hashtable_level _static_level;
    hashtable_stack _dynamic_level;
    bool _to_be_freed; /* should be true for dynamic, false for statically allocated structures */
    bool _dynamic;
};

impl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }
void impl_nocasestring_NoCaseStr::make_own(int length) {
    kc_char_t *newname=new kc_char_t[length+1];
    for (int i=0; i < length && name[i]; ++i)
    newname[i] = kc_tolower(name[i]);
    newname[length]=0;
    name=newname;
}

impl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }
void impl_casestring__Str::make_own(int length) {
    kc_char_t *newname=kc_strncpy(new kc_char_t[length+1],name,length);
    newname[length]=0;
    name=newname;
}
abstract_phylum impl_constant_literal_StringConstant::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_constant_literal_CharConstant::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_constant_literal_RealConstant::subphylum(int no) const
{
    switch(no){
	case 0: return real_1;
    }
    return 0;
}
abstract_phylum impl_constant_literal_IntegerConstant::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_expression_And::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Mod::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Div::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Slash::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Asterisk::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Or::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Minus::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Plus::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Geq::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Leq::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Ge::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Le::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Ne::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_Eq::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_expression_ConstantLiteral::subphylum(int no) const
{
    switch(no){
	case 0: return constant_literal_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExFunctionCall::subphylum(int no) const
{
    switch(no){
	case 0: return function_call_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExVariableDesignator::subphylum(int no) const
{
    switch(no){
	case 0: return variable_designator_1;
    }
    return 0;
}
abstract_phylum impl_expression_Not::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_sequence::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_expression_list::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_list_1;
    }
    return 0;
}
abstract_phylum impl_for_statement_For::subphylum(int no) const
{
    switch(no){
	case 0: return variable_designator_1;
	case 1: return expression_1;
	case 2: return expression_2;
	case 3: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_repeat_statement_Repeat::subphylum(int no) const
{
    switch(no){
	case 0: return statement_sequence_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_while_statement_While::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_opt_else_Else::subphylum(int no) const
{
    switch(no){
	case 0: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_elsif_Elsif::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_elsif_list::subphylum(int no) const
{
    switch(no){
	case 0: return elsif_1;
	case 1: return elsif_list_1;
    }
    return 0;
}
abstract_phylum impl_if_statement_If::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_sequence_1;
	case 2: return elsif_list_1;
	case 3: return opt_else_1;
    }
    return 0;
}
abstract_phylum impl_return_statement_Return::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_function_call_FunctionCall::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_list_1;
    }
    return 0;
}
abstract_phylum impl_assignment_statement_Assignment::subphylum(int no) const
{
    switch(no){
	case 0: return variable_designator_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_ForStatement::subphylum(int no) const
{
    switch(no){
	case 0: return for_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_RepeatStatement::subphylum(int no) const
{
    switch(no){
	case 0: return repeat_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_WhileStatement::subphylum(int no) const
{
    switch(no){
	case 0: return while_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_IfStatement::subphylum(int no) const
{
    switch(no){
	case 0: return if_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_ReturnStatement::subphylum(int no) const
{
    switch(no){
	case 0: return return_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_FunctionCallStatement::subphylum(int no) const
{
    switch(no){
	case 0: return function_call_1;
    }
    return 0;
}
abstract_phylum impl_statement_AssignmentStatement::subphylum(int no) const
{
    switch(no){
	case 0: return assignment_statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_EmptyStatement::subphylum(int no) const
{
    switch(no){
	case 0: return empty_statement_1;
    }
    return 0;
}
abstract_phylum impl_subrange_Subrange::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_type_denoter_TypeArray::subphylum(int no) const
{
    switch(no){
	case 0: return subrange_1;
	case 1: return type_denoter_1;
    }
    return 0;
}
abstract_phylum impl_type_denoter_TypeIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_variable_designator_IndexedVariableDesignator::subphylum(int no) const
{
    switch(no){
	case 0: return variable_designator_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_variable_designator_VariableDesignator::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_parameter_Parameter::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return type_denoter_1;
    }
    return 0;
}
abstract_phylum impl_parameter_list::subphylum(int no) const
{
    switch(no){
	case 0: return parameter_1;
	case 1: return parameter_list_1;
    }
    return 0;
}
abstract_phylum impl_procedure_declaration_Procedure::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return parameter_list_1;
	case 2: return type_denoter_1;
	case 3: return block_1;
    }
    return 0;
}
abstract_phylum impl_variable_declaration_VariableDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return type_denoter_1;
    }
    return 0;
}
abstract_phylum impl_variable_declaration_list::subphylum(int no) const
{
    switch(no){
	case 0: return variable_declaration_1;
	case 1: return variable_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_type_declaration_TypeDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return type_denoter_1;
    }
    return 0;
}
abstract_phylum impl_type_declaration_list::subphylum(int no) const
{
    switch(no){
	case 0: return type_declaration_1;
	case 1: return type_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_constant_declaration_ConstantDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_constant_declaration_list::subphylum(int no) const
{
    switch(no){
	case 0: return constant_declaration_1;
	case 1: return constant_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_declaration_ProcedureDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return procedure_declaration_1;
    }
    return 0;
}
abstract_phylum impl_declaration_VariableDeclarationList::subphylum(int no) const
{
    switch(no){
	case 0: return variable_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_declaration_TypeDeclarationList::subphylum(int no) const
{
    switch(no){
	case 0: return type_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_declaration_ConstantDeclarationList::subphylum(int no) const
{
    switch(no){
	case 0: return constant_declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_declaration_list::subphylum(int no) const
{
    switch(no){
	case 0: return declaration_1;
	case 1: return declaration_list_1;
    }
    return 0;
}
abstract_phylum impl_block_Block::subphylum(int no) const
{
    switch(no){
	case 0: return declaration_list_1;
	case 1: return statement_sequence_1;
    }
    return 0;
}
abstract_phylum impl_module_Module::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return block_1;
    }
    return 0;
}
void impl_constant_literal_StringConstant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_literal_CharConstant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_literal_RealConstant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = real_1 = dynamic_cast<real>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_literal_IntegerConstant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_And::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Mod::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Div::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Slash::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Asterisk::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Or::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Minus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Plus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Geq::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Leq::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Ge::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Le::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Ne::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Eq::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ConstantLiteral::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = constant_literal_1 = dynamic_cast<constant_literal>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExFunctionCall::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = function_call_1 = dynamic_cast<function_call>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExVariableDesignator::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_designator_1 = dynamic_cast<variable_designator>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_Not::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_sequence::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_list_1 = dynamic_cast<expression_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_for_statement_For::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_designator_1 = dynamic_cast<variable_designator>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 3: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_repeat_statement_Repeat::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_while_statement_While::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_opt_else_Else::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_elsif_Elsif::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_elsif_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = elsif_1 = dynamic_cast<elsif>(val);break;
	case 1: newval = elsif_list_1 = dynamic_cast<elsif_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_if_statement_If::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
	case 2: newval = elsif_list_1 = dynamic_cast<elsif_list>(val);break;
	case 3: newval = opt_else_1 = dynamic_cast<opt_else>(val);break;
    }
    assertNonNull(newval);
}
void impl_return_statement_Return::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_function_call_FunctionCall::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_list_1 = dynamic_cast<expression_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_statement_Assignment::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_designator_1 = dynamic_cast<variable_designator>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_ForStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = for_statement_1 = dynamic_cast<for_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_RepeatStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = repeat_statement_1 = dynamic_cast<repeat_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_WhileStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = while_statement_1 = dynamic_cast<while_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_IfStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = if_statement_1 = dynamic_cast<if_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_ReturnStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = return_statement_1 = dynamic_cast<return_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_FunctionCallStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = function_call_1 = dynamic_cast<function_call>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_AssignmentStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = assignment_statement_1 = dynamic_cast<assignment_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_EmptyStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = empty_statement_1 = dynamic_cast<empty_statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_subrange_Subrange::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_denoter_TypeArray::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = subrange_1 = dynamic_cast<subrange>(val);break;
	case 1: newval = type_denoter_1 = dynamic_cast<type_denoter>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_denoter_TypeIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_designator_IndexedVariableDesignator::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_designator_1 = dynamic_cast<variable_designator>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_designator_VariableDesignator::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_parameter_Parameter::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = type_denoter_1 = dynamic_cast<type_denoter>(val);break;
    }
    assertNonNull(newval);
}
void impl_parameter_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = parameter_1 = dynamic_cast<parameter>(val);break;
	case 1: newval = parameter_list_1 = dynamic_cast<parameter_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_procedure_declaration_Procedure::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = parameter_list_1 = dynamic_cast<parameter_list>(val);break;
	case 2: newval = type_denoter_1 = dynamic_cast<type_denoter>(val);break;
	case 3: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_declaration_VariableDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = type_denoter_1 = dynamic_cast<type_denoter>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_declaration_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_declaration_1 = dynamic_cast<variable_declaration>(val);break;
	case 1: newval = variable_declaration_list_1 = dynamic_cast<variable_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_declaration_TypeDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = type_denoter_1 = dynamic_cast<type_denoter>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_declaration_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_declaration_1 = dynamic_cast<type_declaration>(val);break;
	case 1: newval = type_declaration_list_1 = dynamic_cast<type_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_declaration_ConstantDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_declaration_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = constant_declaration_1 = dynamic_cast<constant_declaration>(val);break;
	case 1: newval = constant_declaration_list_1 = dynamic_cast<constant_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_ProcedureDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = procedure_declaration_1 = dynamic_cast<procedure_declaration>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_VariableDeclarationList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = variable_declaration_list_1 = dynamic_cast<variable_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_TypeDeclarationList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_declaration_list_1 = dynamic_cast<type_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_ConstantDeclarationList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = constant_declaration_list_1 = dynamic_cast<constant_declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declaration_1 = dynamic_cast<declaration>(val);break;
	case 1: newval = declaration_list_1 = dynamic_cast<declaration_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_block_Block::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declaration_list_1 = dynamic_cast<declaration_list>(val);break;
	case 1: newval = statement_sequence_1 = dynamic_cast<statement_sequence>(val);break;
    }
    assertNonNull(newval);
}
void impl_module_Module::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}

void
copy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)
{
    switch(copyPhy) {
    case one_before_first_phylum: // just to avoid a warning about missing case if empty
    default:
	break; // it's alright, no attributes to copy
    }
    enum_operators copyOp=kc_p1->prod_sel();
    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)
	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);
}

KC_PHYLUM_INFO phylum_info[] = {
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */
    { "nocasestring", sel_NoCaseStr, sel_NoCaseStr, uniq },
    { "casestring", sel__Str, sel__Str, uniq },
    { "real", sel__Real, sel__Real, uniq },
    { "integer", sel__Int, sel__Int, uniq },
    { "voidptr", sel__VoidPtr, sel__VoidPtr, uniq },
    { "module", sel_Module, sel_Module, kc_not_uniq },
    { "block", sel_Block, sel_Block, kc_not_uniq },
    { "declaration_list", sel_Nildeclaration_list, sel_Consdeclaration_list, kc_not_uniq },
    { "declaration", sel_ConstantDeclarationList, sel_ProcedureDeclaration, kc_not_uniq },
    { "constant_declaration_list", sel_Nilconstant_declaration_list, sel_Consconstant_declaration_list, kc_not_uniq },
    { "constant_declaration", sel_ConstantDeclaration, sel_ConstantDeclaration, kc_not_uniq },
    { "type_declaration_list", sel_Niltype_declaration_list, sel_Constype_declaration_list, kc_not_uniq },
    { "type_declaration", sel_TypeDeclaration, sel_TypeDeclaration, kc_not_uniq },
    { "variable_declaration_list", sel_Nilvariable_declaration_list, sel_Consvariable_declaration_list, kc_not_uniq },
    { "variable_declaration", sel_VariableDeclaration, sel_VariableDeclaration, kc_not_uniq },
    { "procedure_declaration", sel_Procedure, sel_Procedure, kc_not_uniq },
    { "parameter_list", sel_Nilparameter_list, sel_Consparameter_list, kc_not_uniq },
    { "parameter", sel_Parameter, sel_Parameter, kc_not_uniq },
    { "variable_designator", sel_VariableDesignator, sel_IndexedVariableDesignator, kc_not_uniq },
    { "type_denoter", sel_TypeIdent, sel_TypeArray, kc_not_uniq },
    { "subrange", sel_Subrange, sel_Subrange, kc_not_uniq },
    { "statement", sel_EmptyStatement, sel_ForStatement, kc_not_uniq },
    { "empty_statement", sel_Empty, sel_Empty, kc_not_uniq },
    { "assignment_statement", sel_Assignment, sel_Assignment, kc_not_uniq },
    { "function_call", sel_FunctionCall, sel_FunctionCall, kc_not_uniq },
    { "return_statement", sel_Return, sel_Return, kc_not_uniq },
    { "if_statement", sel_If, sel_If, kc_not_uniq },
    { "elsif_list", sel_Nilelsif_list, sel_Conselsif_list, kc_not_uniq },
    { "elsif", sel_Elsif, sel_Elsif, kc_not_uniq },
    { "opt_else", sel_NoElse, sel_Else, kc_not_uniq },
    { "while_statement", sel_While, sel_While, kc_not_uniq },
    { "repeat_statement", sel_Repeat, sel_Repeat, kc_not_uniq },
    { "for_statement", sel_For, sel_For, kc_not_uniq },
    { "expression_list", sel_Nilexpression_list, sel_Consexpression_list, kc_not_uniq },
    { "statement_sequence", sel_Nilstatement_sequence, sel_Consstatement_sequence, kc_not_uniq },
    { "expression", sel_Not, sel_And, kc_not_uniq },
    { "constant_literal", sel_IntegerConstant, sel_StringConstant, kc_not_uniq },
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */
};

static enum_phyla kc_subphyla_Module[] = { phylum_casestring, phylum_block };
static enum_phyla kc_subphyla_Block[] = { phylum_declaration_list, phylum_statement_sequence };
static enum_phyla kc_subphyla_Consdeclaration_list[] = { phylum_declaration, phylum_declaration_list };
static enum_phyla kc_subphyla_ConstantDeclarationList[] = { phylum_constant_declaration_list };
static enum_phyla kc_subphyla_TypeDeclarationList[] = { phylum_type_declaration_list };
static enum_phyla kc_subphyla_VariableDeclarationList[] = { phylum_variable_declaration_list };
static enum_phyla kc_subphyla_ProcedureDeclaration[] = { phylum_procedure_declaration };
static enum_phyla kc_subphyla_Consconstant_declaration_list[] = { phylum_constant_declaration, phylum_constant_declaration_list };
static enum_phyla kc_subphyla_ConstantDeclaration[] = { phylum_casestring, phylum_expression };
static enum_phyla kc_subphyla_Constype_declaration_list[] = { phylum_type_declaration, phylum_type_declaration_list };
static enum_phyla kc_subphyla_TypeDeclaration[] = { phylum_casestring, phylum_type_denoter };
static enum_phyla kc_subphyla_Consvariable_declaration_list[] = { phylum_variable_declaration, phylum_variable_declaration_list };
static enum_phyla kc_subphyla_VariableDeclaration[] = { phylum_casestring, phylum_type_denoter };
static enum_phyla kc_subphyla_Procedure[] = { phylum_casestring, phylum_parameter_list, phylum_type_denoter, phylum_block };
static enum_phyla kc_subphyla_Consparameter_list[] = { phylum_parameter, phylum_parameter_list };
static enum_phyla kc_subphyla_Parameter[] = { phylum_casestring, phylum_type_denoter };
static enum_phyla kc_subphyla_VariableDesignator[] = { phylum_casestring };
static enum_phyla kc_subphyla_IndexedVariableDesignator[] = { phylum_variable_designator, phylum_expression };
static enum_phyla kc_subphyla_TypeIdent[] = { phylum_casestring };
static enum_phyla kc_subphyla_TypeArray[] = { phylum_subrange, phylum_type_denoter };
static enum_phyla kc_subphyla_Subrange[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_EmptyStatement[] = { phylum_empty_statement };
static enum_phyla kc_subphyla_AssignmentStatement[] = { phylum_assignment_statement };
static enum_phyla kc_subphyla_FunctionCallStatement[] = { phylum_function_call };
static enum_phyla kc_subphyla_ReturnStatement[] = { phylum_return_statement };
static enum_phyla kc_subphyla_IfStatement[] = { phylum_if_statement };
static enum_phyla kc_subphyla_WhileStatement[] = { phylum_while_statement };
static enum_phyla kc_subphyla_RepeatStatement[] = { phylum_repeat_statement };
static enum_phyla kc_subphyla_ForStatement[] = { phylum_for_statement };
static enum_phyla kc_subphyla_Assignment[] = { phylum_variable_designator, phylum_expression };
static enum_phyla kc_subphyla_FunctionCall[] = { phylum_casestring, phylum_expression_list };
static enum_phyla kc_subphyla_Return[] = { phylum_expression };
static enum_phyla kc_subphyla_If[] = { phylum_expression, phylum_statement_sequence, phylum_elsif_list, phylum_opt_else };
static enum_phyla kc_subphyla_Conselsif_list[] = { phylum_elsif, phylum_elsif_list };
static enum_phyla kc_subphyla_Elsif[] = { phylum_expression, phylum_statement_sequence };
static enum_phyla kc_subphyla_Else[] = { phylum_statement_sequence };
static enum_phyla kc_subphyla_While[] = { phylum_expression, phylum_statement_sequence };
static enum_phyla kc_subphyla_Repeat[] = { phylum_statement_sequence, phylum_expression };
static enum_phyla kc_subphyla_For[] = { phylum_variable_designator, phylum_expression, phylum_expression, phylum_statement_sequence };
static enum_phyla kc_subphyla_Consexpression_list[] = { phylum_expression, phylum_expression_list };
static enum_phyla kc_subphyla_Consstatement_sequence[] = { phylum_statement, phylum_statement_sequence };
static enum_phyla kc_subphyla_Not[] = { phylum_expression };
static enum_phyla kc_subphyla_ExVariableDesignator[] = { phylum_variable_designator };
static enum_phyla kc_subphyla_ExFunctionCall[] = { phylum_function_call };
static enum_phyla kc_subphyla_ConstantLiteral[] = { phylum_constant_literal };
static enum_phyla kc_subphyla_Eq[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Ne[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Le[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Ge[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Leq[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Geq[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Plus[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Minus[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Or[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Asterisk[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Slash[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Div[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_Mod[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_And[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_IntegerConstant[] = { phylum_integer };
static enum_phyla kc_subphyla_RealConstant[] = { phylum_real };
static enum_phyla kc_subphyla_CharConstant[] = { phylum_casestring };
static enum_phyla kc_subphyla_StringConstant[] = { phylum_casestring };


KC_OPERATOR_INFO operator_info[] = {
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */
    { "NoCaseStr", 0, true, phylum_nocasestring, 0, 0, 0, sizeof(impl_nocasestring_NoCaseStr) },
    { "_Str", 0, true, phylum_casestring, 0, 0, 0, sizeof(impl_casestring__Str) },
    { "_Real", 0, true, phylum_real, 0, 0, 0, sizeof(impl_real__Real) },
    { "_Int", 0, true, phylum_integer, 0, 0, 0, sizeof(impl_integer__Int) },
    { "_VoidPtr", 0, true, phylum_voidptr, 0, 0, 0, sizeof(impl_voidptr__VoidPtr) },
    { "Module", 2, false, phylum_module, kc_subphyla_Module, 0, 0, sizeof(impl_module_Module) },
    { "Block", 2, false, phylum_block, kc_subphyla_Block, 0, 0, sizeof(impl_block_Block) },
    { "Nildeclaration_list", 0, false, phylum_declaration_list, 0, 0, 0, sizeof(impl_declaration_list) },
    { "Consdeclaration_list", 2, false, phylum_declaration_list, kc_subphyla_Consdeclaration_list, 0, 0, sizeof(impl_declaration_list) },
    { "ConstantDeclarationList", 1, false, phylum_declaration, kc_subphyla_ConstantDeclarationList, 0, 0, sizeof(impl_declaration_ConstantDeclarationList) },
    { "TypeDeclarationList", 1, false, phylum_declaration, kc_subphyla_TypeDeclarationList, 0, 0, sizeof(impl_declaration_TypeDeclarationList) },
    { "VariableDeclarationList", 1, false, phylum_declaration, kc_subphyla_VariableDeclarationList, 0, 0, sizeof(impl_declaration_VariableDeclarationList) },
    { "ProcedureDeclaration", 1, false, phylum_declaration, kc_subphyla_ProcedureDeclaration, 0, 0, sizeof(impl_declaration_ProcedureDeclaration) },
    { "Nilconstant_declaration_list", 0, false, phylum_constant_declaration_list, 0, 0, 0, sizeof(impl_constant_declaration_list) },
    { "Consconstant_declaration_list", 2, false, phylum_constant_declaration_list, kc_subphyla_Consconstant_declaration_list, 0, 0, sizeof(impl_constant_declaration_list) },
    { "ConstantDeclaration", 2, false, phylum_constant_declaration, kc_subphyla_ConstantDeclaration, 0, 0, sizeof(impl_constant_declaration_ConstantDeclaration) },
    { "Niltype_declaration_list", 0, false, phylum_type_declaration_list, 0, 0, 0, sizeof(impl_type_declaration_list) },
    { "Constype_declaration_list", 2, false, phylum_type_declaration_list, kc_subphyla_Constype_declaration_list, 0, 0, sizeof(impl_type_declaration_list) },
    { "TypeDeclaration", 2, false, phylum_type_declaration, kc_subphyla_TypeDeclaration, 0, 0, sizeof(impl_type_declaration_TypeDeclaration) },
    { "Nilvariable_declaration_list", 0, false, phylum_variable_declaration_list, 0, 0, 0, sizeof(impl_variable_declaration_list) },
    { "Consvariable_declaration_list", 2, false, phylum_variable_declaration_list, kc_subphyla_Consvariable_declaration_list, 0, 0, sizeof(impl_variable_declaration_list) },
    { "VariableDeclaration", 2, false, phylum_variable_declaration, kc_subphyla_VariableDeclaration, 0, 0, sizeof(impl_variable_declaration_VariableDeclaration) },
    { "Procedure", 4, false, phylum_procedure_declaration, kc_subphyla_Procedure, 0, 0, sizeof(impl_procedure_declaration_Procedure) },
    { "Nilparameter_list", 0, false, phylum_parameter_list, 0, 0, 0, sizeof(impl_parameter_list) },
    { "Consparameter_list", 2, false, phylum_parameter_list, kc_subphyla_Consparameter_list, 0, 0, sizeof(impl_parameter_list) },
    { "Parameter", 2, false, phylum_parameter, kc_subphyla_Parameter, 0, 0, sizeof(impl_parameter_Parameter) },
    { "VariableDesignator", 1, false, phylum_variable_designator, kc_subphyla_VariableDesignator, 0, 0, sizeof(impl_variable_designator_VariableDesignator) },
    { "IndexedVariableDesignator", 2, false, phylum_variable_designator, kc_subphyla_IndexedVariableDesignator, 0, 0, sizeof(impl_variable_designator_IndexedVariableDesignator) },
    { "TypeIdent", 1, false, phylum_type_denoter, kc_subphyla_TypeIdent, 0, 0, sizeof(impl_type_denoter_TypeIdent) },
    { "TypeInteger", 0, false, phylum_type_denoter, 0, 0, 0, sizeof(impl_type_denoter_TypeInteger) },
    { "TypeReal", 0, false, phylum_type_denoter, 0, 0, 0, sizeof(impl_type_denoter_TypeReal) },
    { "TypeChar", 0, false, phylum_type_denoter, 0, 0, 0, sizeof(impl_type_denoter_TypeChar) },
    { "TypeArray", 2, false, phylum_type_denoter, kc_subphyla_TypeArray, 0, 0, sizeof(impl_type_denoter_TypeArray) },
    { "Subrange", 2, false, phylum_subrange, kc_subphyla_Subrange, 0, 0, sizeof(impl_subrange_Subrange) },
    { "EmptyStatement", 1, false, phylum_statement, kc_subphyla_EmptyStatement, 0, 0, sizeof(impl_statement_EmptyStatement) },
    { "AssignmentStatement", 1, false, phylum_statement, kc_subphyla_AssignmentStatement, 0, 0, sizeof(impl_statement_AssignmentStatement) },
    { "FunctionCallStatement", 1, false, phylum_statement, kc_subphyla_FunctionCallStatement, 0, 0, sizeof(impl_statement_FunctionCallStatement) },
    { "ReturnStatement", 1, false, phylum_statement, kc_subphyla_ReturnStatement, 0, 0, sizeof(impl_statement_ReturnStatement) },
    { "IfStatement", 1, false, phylum_statement, kc_subphyla_IfStatement, 0, 0, sizeof(impl_statement_IfStatement) },
    { "WhileStatement", 1, false, phylum_statement, kc_subphyla_WhileStatement, 0, 0, sizeof(impl_statement_WhileStatement) },
    { "RepeatStatement", 1, false, phylum_statement, kc_subphyla_RepeatStatement, 0, 0, sizeof(impl_statement_RepeatStatement) },
    { "ForStatement", 1, false, phylum_statement, kc_subphyla_ForStatement, 0, 0, sizeof(impl_statement_ForStatement) },
    { "Empty", 0, false, phylum_empty_statement, 0, 0, 0, sizeof(impl_empty_statement_Empty) },
    { "Assignment", 2, false, phylum_assignment_statement, kc_subphyla_Assignment, 0, 0, sizeof(impl_assignment_statement_Assignment) },
    { "FunctionCall", 2, false, phylum_function_call, kc_subphyla_FunctionCall, 0, 0, sizeof(impl_function_call_FunctionCall) },
    { "Return", 1, false, phylum_return_statement, kc_subphyla_Return, 0, 0, sizeof(impl_return_statement_Return) },
    { "If", 4, false, phylum_if_statement, kc_subphyla_If, 0, 0, sizeof(impl_if_statement_If) },
    { "Nilelsif_list", 0, false, phylum_elsif_list, 0, 0, 0, sizeof(impl_elsif_list) },
    { "Conselsif_list", 2, false, phylum_elsif_list, kc_subphyla_Conselsif_list, 0, 0, sizeof(impl_elsif_list) },
    { "Elsif", 2, false, phylum_elsif, kc_subphyla_Elsif, 0, 0, sizeof(impl_elsif_Elsif) },
    { "NoElse", 0, false, phylum_opt_else, 0, 0, 0, sizeof(impl_opt_else_NoElse) },
    { "Else", 1, false, phylum_opt_else, kc_subphyla_Else, 0, 0, sizeof(impl_opt_else_Else) },
    { "While", 2, false, phylum_while_statement, kc_subphyla_While, 0, 0, sizeof(impl_while_statement_While) },
    { "Repeat", 2, false, phylum_repeat_statement, kc_subphyla_Repeat, 0, 0, sizeof(impl_repeat_statement_Repeat) },
    { "For", 4, false, phylum_for_statement, kc_subphyla_For, 0, 0, sizeof(impl_for_statement_For) },
    { "Nilexpression_list", 0, false, phylum_expression_list, 0, 0, 0, sizeof(impl_expression_list) },
    { "Consexpression_list", 2, false, phylum_expression_list, kc_subphyla_Consexpression_list, 0, 0, sizeof(impl_expression_list) },
    { "Nilstatement_sequence", 0, false, phylum_statement_sequence, 0, 0, 0, sizeof(impl_statement_sequence) },
    { "Consstatement_sequence", 2, false, phylum_statement_sequence, kc_subphyla_Consstatement_sequence, 0, 0, sizeof(impl_statement_sequence) },
    { "Not", 1, false, phylum_expression, kc_subphyla_Not, 0, 0, sizeof(impl_expression_Not) },
    { "ExVariableDesignator", 1, false, phylum_expression, kc_subphyla_ExVariableDesignator, 0, 0, sizeof(impl_expression_ExVariableDesignator) },
    { "ExFunctionCall", 1, false, phylum_expression, kc_subphyla_ExFunctionCall, 0, 0, sizeof(impl_expression_ExFunctionCall) },
    { "ConstantLiteral", 1, false, phylum_expression, kc_subphyla_ConstantLiteral, 0, 0, sizeof(impl_expression_ConstantLiteral) },
    { "Eq", 2, false, phylum_expression, kc_subphyla_Eq, 0, 0, sizeof(impl_expression_Eq) },
    { "Ne", 2, false, phylum_expression, kc_subphyla_Ne, 0, 0, sizeof(impl_expression_Ne) },
    { "Le", 2, false, phylum_expression, kc_subphyla_Le, 0, 0, sizeof(impl_expression_Le) },
    { "Ge", 2, false, phylum_expression, kc_subphyla_Ge, 0, 0, sizeof(impl_expression_Ge) },
    { "Leq", 2, false, phylum_expression, kc_subphyla_Leq, 0, 0, sizeof(impl_expression_Leq) },
    { "Geq", 2, false, phylum_expression, kc_subphyla_Geq, 0, 0, sizeof(impl_expression_Geq) },
    { "Plus", 2, false, phylum_expression, kc_subphyla_Plus, 0, 0, sizeof(impl_expression_Plus) },
    { "Minus", 2, false, phylum_expression, kc_subphyla_Minus, 0, 0, sizeof(impl_expression_Minus) },
    { "Or", 2, false, phylum_expression, kc_subphyla_Or, 0, 0, sizeof(impl_expression_Or) },
    { "Asterisk", 2, false, phylum_expression, kc_subphyla_Asterisk, 0, 0, sizeof(impl_expression_Asterisk) },
    { "Slash", 2, false, phylum_expression, kc_subphyla_Slash, 0, 0, sizeof(impl_expression_Slash) },
    { "Div", 2, false, phylum_expression, kc_subphyla_Div, 0, 0, sizeof(impl_expression_Div) },
    { "Mod", 2, false, phylum_expression, kc_subphyla_Mod, 0, 0, sizeof(impl_expression_Mod) },
    { "And", 2, false, phylum_expression, kc_subphyla_And, 0, 0, sizeof(impl_expression_And) },
    { "IntegerConstant", 1, false, phylum_constant_literal, kc_subphyla_IntegerConstant, 0, 0, sizeof(impl_constant_literal_IntegerConstant) },
    { "RealConstant", 1, false, phylum_constant_literal, kc_subphyla_RealConstant, 0, 0, sizeof(impl_constant_literal_RealConstant) },
    { "CharConstant", 1, false, phylum_constant_literal, kc_subphyla_CharConstant, 0, 0, sizeof(impl_constant_literal_CharConstant) },
    { "StringConstant", 1, false, phylum_constant_literal, kc_subphyla_StringConstant, 0, 0, sizeof(impl_constant_literal_StringConstant) },
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */
};

static enum_phyla phylumstorageclass_uniq[] = { one_before_first_phylum, phylum_nocasestring, phylum_casestring, phylum_real, phylum_integer, phylum_voidptr, last_phylum };

KC_UNIQ_INFO kc_UniqInfo[] = {
    (KC_UNIQ_INFO)0,
    phylumstorageclass_uniq
};

} // namespace kc

namespace kc {

void
kc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN_WITH);
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: function %s does not return a value, at %s:%d");
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: function %s does not return a value, at %s:%d", kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionFailed(const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    TRACE( format, tkc_func, kc_l );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d\n", kc_fn, kc_l );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at file %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_s);
    TRACE( format, tkc_func, kc_l, tkc_s );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at file %s:%d: %s\n", kc_fn, kc_l, kc_s );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionNonNullFailed(const char *kc_fn, int kc_l, const char *kc_str)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_str);
    TRACE( format , tkc_func, kc_l, tkc_s);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n", kc_fn, kc_l, kc_str );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s1=A2CT(kc_str1);
    const _TCHAR* tkc_s2=A2CT(kc_str2);
    const _TCHAR* tname=A2CT(kc_phy);
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );
    } else {
	format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n");
	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);
	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);
	TRACE(format,tkc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );
    }
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, kc_op );
    } else {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );
    }
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: invalid operator code in %s%s at %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_func_prefix);
    const _TCHAR* tkc_file=A2CT(kc_file);
    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));
    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));
    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: invalid operator code in %s%s at %s:%d: %s\n", kc_func_prefix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));
#ifndef KC_INVALID_OPERATOR_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}
const enum_phyla impl_nocasestring::phylum_sel_ = phylum_nocasestring;
const enum_phyla impl_casestring::phylum_sel_ = phylum_casestring;
const enum_phyla impl_real::phylum_sel_ = phylum_real;
impl_real__Real::impl_real__Real(REAL _value)
    : value(_value) { }
const enum_phyla impl_integer::phylum_sel_ = phylum_integer;
impl_integer__Int::impl_integer__Int(INTEGER _value)
    : value(_value) { }
const enum_phyla impl_voidptr::phylum_sel_ = phylum_voidptr;
impl_voidptr__VoidPtr::impl_voidptr__VoidPtr(void* _pointer)
    : pointer(_pointer) { }
const enum_phyla impl_module::phylum_sel_ = phylum_module;
impl_module_Module::impl_module_Module(casestring _casestring_1, block _block_1)
    : casestring_1(_casestring_1), block_1(_block_1) { }
const enum_phyla impl_block::phylum_sel_ = phylum_block;
impl_block_Block::impl_block_Block(declaration_list _declaration_list_1, statement_sequence _statement_sequence_1)
    : declaration_list_1(_declaration_list_1), statement_sequence_1(_statement_sequence_1) { }
const enum_phyla impl_declaration_list::phylum_sel_ = phylum_declaration_list;
impl_declaration_list::impl_declaration_list(declaration p1 , declaration_list p2)
    : declaration_1(p1), declaration_list_1(p2) { }
const enum_phyla impl_declaration::phylum_sel_ = phylum_declaration;
impl_declaration_ProcedureDeclaration::impl_declaration_ProcedureDeclaration(procedure_declaration _procedure_declaration_1)
    : procedure_declaration_1(_procedure_declaration_1) { }
impl_declaration_VariableDeclarationList::impl_declaration_VariableDeclarationList(variable_declaration_list _variable_declaration_list_1)
    : variable_declaration_list_1(_variable_declaration_list_1) { }
impl_declaration_TypeDeclarationList::impl_declaration_TypeDeclarationList(type_declaration_list _type_declaration_list_1)
    : type_declaration_list_1(_type_declaration_list_1) { }
impl_declaration_ConstantDeclarationList::impl_declaration_ConstantDeclarationList(constant_declaration_list _constant_declaration_list_1)
    : constant_declaration_list_1(_constant_declaration_list_1) { }
const enum_phyla impl_constant_declaration_list::phylum_sel_ = phylum_constant_declaration_list;
impl_constant_declaration_list::impl_constant_declaration_list(constant_declaration p1 , constant_declaration_list p2)
    : constant_declaration_1(p1), constant_declaration_list_1(p2) { }
const enum_phyla impl_constant_declaration::phylum_sel_ = phylum_constant_declaration;
impl_constant_declaration_ConstantDeclaration::impl_constant_declaration_ConstantDeclaration(casestring _casestring_1, expression _expression_1)
    : casestring_1(_casestring_1), expression_1(_expression_1) { }
const enum_phyla impl_type_declaration_list::phylum_sel_ = phylum_type_declaration_list;
impl_type_declaration_list::impl_type_declaration_list(type_declaration p1 , type_declaration_list p2)
    : type_declaration_1(p1), type_declaration_list_1(p2) { }
const enum_phyla impl_type_declaration::phylum_sel_ = phylum_type_declaration;
impl_type_declaration_TypeDeclaration::impl_type_declaration_TypeDeclaration(casestring _casestring_1, type_denoter _type_denoter_1)
    : casestring_1(_casestring_1), type_denoter_1(_type_denoter_1) { }
const enum_phyla impl_variable_declaration_list::phylum_sel_ = phylum_variable_declaration_list;
impl_variable_declaration_list::impl_variable_declaration_list(variable_declaration p1 , variable_declaration_list p2)
    : variable_declaration_1(p1), variable_declaration_list_1(p2) { }
const enum_phyla impl_variable_declaration::phylum_sel_ = phylum_variable_declaration;
impl_variable_declaration_VariableDeclaration::impl_variable_declaration_VariableDeclaration(casestring _casestring_1, type_denoter _type_denoter_1)
    : casestring_1(_casestring_1), type_denoter_1(_type_denoter_1) { }
const enum_phyla impl_procedure_declaration::phylum_sel_ = phylum_procedure_declaration;
impl_procedure_declaration_Procedure::impl_procedure_declaration_Procedure(casestring _casestring_1, parameter_list _parameter_list_1, type_denoter _type_denoter_1, block _block_1)
    : casestring_1(_casestring_1), parameter_list_1(_parameter_list_1), type_denoter_1(_type_denoter_1), block_1(_block_1) { }
const enum_phyla impl_parameter_list::phylum_sel_ = phylum_parameter_list;
impl_parameter_list::impl_parameter_list(parameter p1 , parameter_list p2)
    : parameter_1(p1), parameter_list_1(p2) { }
const enum_phyla impl_parameter::phylum_sel_ = phylum_parameter;
impl_parameter_Parameter::impl_parameter_Parameter(casestring _casestring_1, type_denoter _type_denoter_1)
    : casestring_1(_casestring_1), type_denoter_1(_type_denoter_1) { }
const enum_phyla impl_variable_designator::phylum_sel_ = phylum_variable_designator;
impl_variable_designator_IndexedVariableDesignator::impl_variable_designator_IndexedVariableDesignator(variable_designator _variable_designator_1, expression _expression_1)
    : variable_designator_1(_variable_designator_1), expression_1(_expression_1) { }
impl_variable_designator_VariableDesignator::impl_variable_designator_VariableDesignator(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_type_denoter::phylum_sel_ = phylum_type_denoter;
impl_type_denoter_TypeArray::impl_type_denoter_TypeArray(subrange _subrange_1, type_denoter _type_denoter_1)
    : subrange_1(_subrange_1), type_denoter_1(_type_denoter_1) { }
impl_type_denoter_TypeChar::impl_type_denoter_TypeChar()
    { }
impl_type_denoter_TypeReal::impl_type_denoter_TypeReal()
    { }
impl_type_denoter_TypeInteger::impl_type_denoter_TypeInteger()
    { }
impl_type_denoter_TypeIdent::impl_type_denoter_TypeIdent(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_subrange::phylum_sel_ = phylum_subrange;
impl_subrange_Subrange::impl_subrange_Subrange(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
const enum_phyla impl_statement::phylum_sel_ = phylum_statement;
impl_statement_ForStatement::impl_statement_ForStatement(for_statement _for_statement_1)
    : for_statement_1(_for_statement_1) { }
impl_statement_RepeatStatement::impl_statement_RepeatStatement(repeat_statement _repeat_statement_1)
    : repeat_statement_1(_repeat_statement_1) { }
impl_statement_WhileStatement::impl_statement_WhileStatement(while_statement _while_statement_1)
    : while_statement_1(_while_statement_1) { }
impl_statement_IfStatement::impl_statement_IfStatement(if_statement _if_statement_1)
    : if_statement_1(_if_statement_1) { }
impl_statement_ReturnStatement::impl_statement_ReturnStatement(return_statement _return_statement_1)
    : return_statement_1(_return_statement_1) { }
impl_statement_FunctionCallStatement::impl_statement_FunctionCallStatement(function_call _function_call_1)
    : function_call_1(_function_call_1) { }
impl_statement_AssignmentStatement::impl_statement_AssignmentStatement(assignment_statement _assignment_statement_1)
    : assignment_statement_1(_assignment_statement_1) { }
impl_statement_EmptyStatement::impl_statement_EmptyStatement(empty_statement _empty_statement_1)
    : empty_statement_1(_empty_statement_1) { }
const enum_phyla impl_empty_statement::phylum_sel_ = phylum_empty_statement;
impl_empty_statement_Empty::impl_empty_statement_Empty()
    { }
const enum_phyla impl_assignment_statement::phylum_sel_ = phylum_assignment_statement;
impl_assignment_statement_Assignment::impl_assignment_statement_Assignment(variable_designator _variable_designator_1, expression _expression_1)
    : variable_designator_1(_variable_designator_1), expression_1(_expression_1) { }
const enum_phyla impl_function_call::phylum_sel_ = phylum_function_call;
impl_function_call_FunctionCall::impl_function_call_FunctionCall(casestring _casestring_1, expression_list _expression_list_1)
    : casestring_1(_casestring_1), expression_list_1(_expression_list_1) { }
const enum_phyla impl_return_statement::phylum_sel_ = phylum_return_statement;
impl_return_statement_Return::impl_return_statement_Return(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_if_statement::phylum_sel_ = phylum_if_statement;
impl_if_statement_If::impl_if_statement_If(expression _expression_1, statement_sequence _statement_sequence_1, elsif_list _elsif_list_1, opt_else _opt_else_1)
    : expression_1(_expression_1), statement_sequence_1(_statement_sequence_1), elsif_list_1(_elsif_list_1), opt_else_1(_opt_else_1) { }
const enum_phyla impl_elsif_list::phylum_sel_ = phylum_elsif_list;
impl_elsif_list::impl_elsif_list(elsif p1 , elsif_list p2)
    : elsif_1(p1), elsif_list_1(p2) { }
const enum_phyla impl_elsif::phylum_sel_ = phylum_elsif;
impl_elsif_Elsif::impl_elsif_Elsif(expression _expression_1, statement_sequence _statement_sequence_1)
    : expression_1(_expression_1), statement_sequence_1(_statement_sequence_1) { }
const enum_phyla impl_opt_else::phylum_sel_ = phylum_opt_else;
impl_opt_else_Else::impl_opt_else_Else(statement_sequence _statement_sequence_1)
    : statement_sequence_1(_statement_sequence_1) { }
impl_opt_else_NoElse::impl_opt_else_NoElse()
    { }
const enum_phyla impl_while_statement::phylum_sel_ = phylum_while_statement;
impl_while_statement_While::impl_while_statement_While(expression _expression_1, statement_sequence _statement_sequence_1)
    : expression_1(_expression_1), statement_sequence_1(_statement_sequence_1) { }
const enum_phyla impl_repeat_statement::phylum_sel_ = phylum_repeat_statement;
impl_repeat_statement_Repeat::impl_repeat_statement_Repeat(statement_sequence _statement_sequence_1, expression _expression_1)
    : statement_sequence_1(_statement_sequence_1), expression_1(_expression_1) { }
const enum_phyla impl_for_statement::phylum_sel_ = phylum_for_statement;
impl_for_statement_For::impl_for_statement_For(variable_designator _variable_designator_1, expression _expression_1, expression _expression_2, statement_sequence _statement_sequence_1)
    : variable_designator_1(_variable_designator_1), expression_1(_expression_1), expression_2(_expression_2), statement_sequence_1(_statement_sequence_1) { }
const enum_phyla impl_expression_list::phylum_sel_ = phylum_expression_list;
impl_expression_list::impl_expression_list(expression p1 , expression_list p2)
    : expression_1(p1), expression_list_1(p2) { }
const enum_phyla impl_statement_sequence::phylum_sel_ = phylum_statement_sequence;
impl_statement_sequence::impl_statement_sequence(statement p1 , statement_sequence p2)
    : statement_1(p1), statement_sequence_1(p2) { }
const enum_phyla impl_expression::phylum_sel_ = phylum_expression;
impl_expression_And::impl_expression_And(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Mod::impl_expression_Mod(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Div::impl_expression_Div(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Slash::impl_expression_Slash(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Asterisk::impl_expression_Asterisk(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Or::impl_expression_Or(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Minus::impl_expression_Minus(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Plus::impl_expression_Plus(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Geq::impl_expression_Geq(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Leq::impl_expression_Leq(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Ge::impl_expression_Ge(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Le::impl_expression_Le(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Ne::impl_expression_Ne(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_Eq::impl_expression_Eq(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_expression_ConstantLiteral::impl_expression_ConstantLiteral(constant_literal _constant_literal_1)
    : constant_literal_1(_constant_literal_1) { }
impl_expression_ExFunctionCall::impl_expression_ExFunctionCall(function_call _function_call_1)
    : function_call_1(_function_call_1) { }
impl_expression_ExVariableDesignator::impl_expression_ExVariableDesignator(variable_designator _variable_designator_1)
    : variable_designator_1(_variable_designator_1) { }
impl_expression_Not::impl_expression_Not(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_constant_literal::phylum_sel_ = phylum_constant_literal;
impl_constant_literal_StringConstant::impl_constant_literal_StringConstant(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_constant_literal_CharConstant::impl_constant_literal_CharConstant(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_constant_literal_RealConstant::impl_constant_literal_RealConstant(real _real_1)
    : real_1(_real_1) { }
impl_constant_literal_IntegerConstant::impl_constant_literal_IntegerConstant(integer _integer_1)
    : integer_1(_integer_1) { }

#ifdef KC_STATISTICS
KC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];
static int kc_casestring_strlen =0;
static int kc_nocasestring_strlen =0;
#  define KC_COLLECT_STATS0(v) v
#else
#  define KC_COLLECT_STATS0(v)
#endif

#ifndef KC_CREATE_STATS
#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;
#endif
#ifndef KC_EXISTINGNOTFOUND_STATS
#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;
#endif

#ifndef KC_FREE_CALLED_STATS
#  define KC_FREE_CALLED_STATS(oper,rec) operator_statistics[oper].free_called[(rec?true:false)]++;
#endif

#ifndef KC_FREED_STATS
#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;
#endif
static hashtable_struct_t kc_not_uniq_static_hashtable;
static hashtable_struct_t uniq_static_hashtable;

bool kc_storageclass_still_uniq[] = {
    true, true };

hashtable_t hashtables[] = {
    &kc_not_uniq_static_hashtable,
    &uniq_static_hashtable,
};

const char* kc_storageclassnames[] = { "kc_not_uniq", "uniq" };

namespace { // all local to k.cc


} // namespace

enum_phyla
impl_abstract_phylum::phylum() const {
    return operator_info[prod_sel()].phylum;
}

const char*
impl_abstract_phylum::phylum_name() const {
    return phylum_info[phylum()].name;
}

const char*
impl_abstract_phylum::op_name() const {
    return operator_info[prod_sel()].name;
}

casestring
mkcasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));

    casestring kc_x=new impl_casestring__Str(kc_s);
    if(length>=0) 
	kc_x->make_own(length);

    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0) 
	    kc_x->name=0;

	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));
	if(length<0) 
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));

	kc_x->post_create();
    }
    return kc_x;
}

nocasestring
mknocasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));

    nocasestring kc_x=new impl_nocasestring_NoCaseStr(kc_s);
    if(length>=0)
	kc_x->make_own(length);
    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0)
	    kc_x->name=0;
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));
	if(length<0)
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));
	kc_x->post_create();
    }

    return kc_x;
}

integer
mkinteger(const INTEGER kc_i)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));

    integer kc_x =new impl_integer__Int(kc_i);
    integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));
	kc_x->post_create();
    }

    return kc_x;
}

real
mkreal(const REAL kc_r)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));

    real kc_x=new impl_real__Real(kc_r);
    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));
	kc_x->post_create();
    }

    return kc_x;
}

voidptr
mkvoidptr(void *kc_p)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));
    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);
    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));
	kc_x->post_create();
    }
    return kc_x;
}

impl_module_Module*
Module(casestring _casestring_1, block _block_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_block_1, phylum_block);
    module kc_x = new impl_module_Module(_casestring_1, _block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Module));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Module));
    kc_x->post_create();
    return static_cast<impl_module_Module*>(kc_x);
}

impl_block_Block*
Block(declaration_list _declaration_list_1, statement_sequence _statement_sequence_1) {
    assertPhylum(_declaration_list_1, phylum_declaration_list);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    block kc_x = new impl_block_Block(_declaration_list_1, _statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Block));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Block));
    kc_x->post_create();
    return static_cast<impl_block_Block*>(kc_x);
}

impl_declaration_list*
Nildeclaration_list() {
    declaration_list kc_x = new impl_declaration_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nildeclaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nildeclaration_list));
    kc_x->post_create();
    return static_cast<impl_declaration_list*>(kc_x);
}

impl_declaration_list*
Consdeclaration_list(declaration _declaration_1, declaration_list _declaration_list_1) {
    assertPhylum(_declaration_1, phylum_declaration);
    assertPhylum(_declaration_list_1, phylum_declaration_list);
    declaration_list kc_x = new impl_declaration_list(_declaration_1, _declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consdeclaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consdeclaration_list));
    kc_x->post_create();
    return static_cast<impl_declaration_list*>(kc_x);
}

impl_declaration_ConstantDeclarationList*
ConstantDeclarationList(constant_declaration_list _constant_declaration_list_1) {
    assertPhylum(_constant_declaration_list_1, phylum_constant_declaration_list);
    declaration kc_x = new impl_declaration_ConstantDeclarationList(_constant_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstantDeclarationList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstantDeclarationList));
    kc_x->post_create();
    return static_cast<impl_declaration_ConstantDeclarationList*>(kc_x);
}

impl_declaration_TypeDeclarationList*
TypeDeclarationList(type_declaration_list _type_declaration_list_1) {
    assertPhylum(_type_declaration_list_1, phylum_type_declaration_list);
    declaration kc_x = new impl_declaration_TypeDeclarationList(_type_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeDeclarationList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeDeclarationList));
    kc_x->post_create();
    return static_cast<impl_declaration_TypeDeclarationList*>(kc_x);
}

impl_declaration_VariableDeclarationList*
VariableDeclarationList(variable_declaration_list _variable_declaration_list_1) {
    assertPhylum(_variable_declaration_list_1, phylum_variable_declaration_list);
    declaration kc_x = new impl_declaration_VariableDeclarationList(_variable_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VariableDeclarationList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VariableDeclarationList));
    kc_x->post_create();
    return static_cast<impl_declaration_VariableDeclarationList*>(kc_x);
}

impl_declaration_ProcedureDeclaration*
ProcedureDeclaration(procedure_declaration _procedure_declaration_1) {
    assertPhylum(_procedure_declaration_1, phylum_procedure_declaration);
    declaration kc_x = new impl_declaration_ProcedureDeclaration(_procedure_declaration_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ProcedureDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ProcedureDeclaration));
    kc_x->post_create();
    return static_cast<impl_declaration_ProcedureDeclaration*>(kc_x);
}

impl_constant_declaration_list*
Nilconstant_declaration_list() {
    constant_declaration_list kc_x = new impl_constant_declaration_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilconstant_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilconstant_declaration_list));
    kc_x->post_create();
    return static_cast<impl_constant_declaration_list*>(kc_x);
}

impl_constant_declaration_list*
Consconstant_declaration_list(constant_declaration _constant_declaration_1, constant_declaration_list _constant_declaration_list_1) {
    assertPhylum(_constant_declaration_1, phylum_constant_declaration);
    assertPhylum(_constant_declaration_list_1, phylum_constant_declaration_list);
    constant_declaration_list kc_x = new impl_constant_declaration_list(_constant_declaration_1, _constant_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consconstant_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consconstant_declaration_list));
    kc_x->post_create();
    return static_cast<impl_constant_declaration_list*>(kc_x);
}

impl_constant_declaration_ConstantDeclaration*
ConstantDeclaration(casestring _casestring_1, expression _expression_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    constant_declaration kc_x = new impl_constant_declaration_ConstantDeclaration(_casestring_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstantDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstantDeclaration));
    kc_x->post_create();
    return static_cast<impl_constant_declaration_ConstantDeclaration*>(kc_x);
}

impl_type_declaration_list*
Niltype_declaration_list() {
    type_declaration_list kc_x = new impl_type_declaration_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Niltype_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Niltype_declaration_list));
    kc_x->post_create();
    return static_cast<impl_type_declaration_list*>(kc_x);
}

impl_type_declaration_list*
Constype_declaration_list(type_declaration _type_declaration_1, type_declaration_list _type_declaration_list_1) {
    assertPhylum(_type_declaration_1, phylum_type_declaration);
    assertPhylum(_type_declaration_list_1, phylum_type_declaration_list);
    type_declaration_list kc_x = new impl_type_declaration_list(_type_declaration_1, _type_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Constype_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Constype_declaration_list));
    kc_x->post_create();
    return static_cast<impl_type_declaration_list*>(kc_x);
}

impl_type_declaration_TypeDeclaration*
TypeDeclaration(casestring _casestring_1, type_denoter _type_denoter_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_type_denoter_1, phylum_type_denoter);
    type_declaration kc_x = new impl_type_declaration_TypeDeclaration(_casestring_1, _type_denoter_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeDeclaration));
    kc_x->post_create();
    return static_cast<impl_type_declaration_TypeDeclaration*>(kc_x);
}

impl_variable_declaration_list*
Nilvariable_declaration_list() {
    variable_declaration_list kc_x = new impl_variable_declaration_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilvariable_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilvariable_declaration_list));
    kc_x->post_create();
    return static_cast<impl_variable_declaration_list*>(kc_x);
}

impl_variable_declaration_list*
Consvariable_declaration_list(variable_declaration _variable_declaration_1, variable_declaration_list _variable_declaration_list_1) {
    assertPhylum(_variable_declaration_1, phylum_variable_declaration);
    assertPhylum(_variable_declaration_list_1, phylum_variable_declaration_list);
    variable_declaration_list kc_x = new impl_variable_declaration_list(_variable_declaration_1, _variable_declaration_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consvariable_declaration_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consvariable_declaration_list));
    kc_x->post_create();
    return static_cast<impl_variable_declaration_list*>(kc_x);
}

impl_variable_declaration_VariableDeclaration*
VariableDeclaration(casestring _casestring_1, type_denoter _type_denoter_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_type_denoter_1, phylum_type_denoter);
    variable_declaration kc_x = new impl_variable_declaration_VariableDeclaration(_casestring_1, _type_denoter_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VariableDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VariableDeclaration));
    kc_x->post_create();
    return static_cast<impl_variable_declaration_VariableDeclaration*>(kc_x);
}

impl_procedure_declaration_Procedure*
Procedure(casestring _casestring_1, parameter_list _parameter_list_1, type_denoter _type_denoter_1, block _block_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_parameter_list_1, phylum_parameter_list);
    assertPhylum(_type_denoter_1, phylum_type_denoter);
    assertPhylum(_block_1, phylum_block);
    procedure_declaration kc_x = new impl_procedure_declaration_Procedure(_casestring_1, _parameter_list_1, _type_denoter_1, _block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Procedure));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Procedure));
    kc_x->post_create();
    return static_cast<impl_procedure_declaration_Procedure*>(kc_x);
}

impl_parameter_list*
Nilparameter_list() {
    parameter_list kc_x = new impl_parameter_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilparameter_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilparameter_list));
    kc_x->post_create();
    return static_cast<impl_parameter_list*>(kc_x);
}

impl_parameter_list*
Consparameter_list(parameter _parameter_1, parameter_list _parameter_list_1) {
    assertPhylum(_parameter_1, phylum_parameter);
    assertPhylum(_parameter_list_1, phylum_parameter_list);
    parameter_list kc_x = new impl_parameter_list(_parameter_1, _parameter_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consparameter_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consparameter_list));
    kc_x->post_create();
    return static_cast<impl_parameter_list*>(kc_x);
}

impl_parameter_Parameter*
Parameter(casestring _casestring_1, type_denoter _type_denoter_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_type_denoter_1, phylum_type_denoter);
    parameter kc_x = new impl_parameter_Parameter(_casestring_1, _type_denoter_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Parameter));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Parameter));
    kc_x->post_create();
    return static_cast<impl_parameter_Parameter*>(kc_x);
}

impl_variable_designator_VariableDesignator*
VariableDesignator(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    variable_designator kc_x = new impl_variable_designator_VariableDesignator(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VariableDesignator));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VariableDesignator));
    kc_x->post_create();
    return static_cast<impl_variable_designator_VariableDesignator*>(kc_x);
}

impl_variable_designator_IndexedVariableDesignator*
IndexedVariableDesignator(variable_designator _variable_designator_1, expression _expression_1) {
    assertPhylum(_variable_designator_1, phylum_variable_designator);
    assertPhylum(_expression_1, phylum_expression);
    variable_designator kc_x = new impl_variable_designator_IndexedVariableDesignator(_variable_designator_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IndexedVariableDesignator));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IndexedVariableDesignator));
    kc_x->post_create();
    return static_cast<impl_variable_designator_IndexedVariableDesignator*>(kc_x);
}

impl_type_denoter_TypeIdent*
TypeIdent(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    type_denoter kc_x = new impl_type_denoter_TypeIdent(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeIdent));
    kc_x->post_create();
    return static_cast<impl_type_denoter_TypeIdent*>(kc_x);
}

impl_type_denoter_TypeInteger*
TypeInteger() {
    type_denoter kc_x = new impl_type_denoter_TypeInteger();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeInteger));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeInteger));
    kc_x->post_create();
    return static_cast<impl_type_denoter_TypeInteger*>(kc_x);
}

impl_type_denoter_TypeReal*
TypeReal() {
    type_denoter kc_x = new impl_type_denoter_TypeReal();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeReal));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeReal));
    kc_x->post_create();
    return static_cast<impl_type_denoter_TypeReal*>(kc_x);
}

impl_type_denoter_TypeChar*
TypeChar() {
    type_denoter kc_x = new impl_type_denoter_TypeChar();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeChar));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeChar));
    kc_x->post_create();
    return static_cast<impl_type_denoter_TypeChar*>(kc_x);
}

impl_type_denoter_TypeArray*
TypeArray(subrange _subrange_1, type_denoter _type_denoter_1) {
    assertPhylum(_subrange_1, phylum_subrange);
    assertPhylum(_type_denoter_1, phylum_type_denoter);
    type_denoter kc_x = new impl_type_denoter_TypeArray(_subrange_1, _type_denoter_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeArray));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeArray));
    kc_x->post_create();
    return static_cast<impl_type_denoter_TypeArray*>(kc_x);
}

impl_subrange_Subrange*
Subrange(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    subrange kc_x = new impl_subrange_Subrange(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Subrange));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Subrange));
    kc_x->post_create();
    return static_cast<impl_subrange_Subrange*>(kc_x);
}

impl_statement_EmptyStatement*
EmptyStatement(empty_statement _empty_statement_1) {
    assertPhylum(_empty_statement_1, phylum_empty_statement);
    statement kc_x = new impl_statement_EmptyStatement(_empty_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyStatement));
    kc_x->post_create();
    return static_cast<impl_statement_EmptyStatement*>(kc_x);
}

impl_statement_AssignmentStatement*
AssignmentStatement(assignment_statement _assignment_statement_1) {
    assertPhylum(_assignment_statement_1, phylum_assignment_statement);
    statement kc_x = new impl_statement_AssignmentStatement(_assignment_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignmentStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignmentStatement));
    kc_x->post_create();
    return static_cast<impl_statement_AssignmentStatement*>(kc_x);
}

impl_statement_FunctionCallStatement*
FunctionCallStatement(function_call _function_call_1) {
    assertPhylum(_function_call_1, phylum_function_call);
    statement kc_x = new impl_statement_FunctionCallStatement(_function_call_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionCallStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionCallStatement));
    kc_x->post_create();
    return static_cast<impl_statement_FunctionCallStatement*>(kc_x);
}

impl_statement_ReturnStatement*
ReturnStatement(return_statement _return_statement_1) {
    assertPhylum(_return_statement_1, phylum_return_statement);
    statement kc_x = new impl_statement_ReturnStatement(_return_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ReturnStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ReturnStatement));
    kc_x->post_create();
    return static_cast<impl_statement_ReturnStatement*>(kc_x);
}

impl_statement_IfStatement*
IfStatement(if_statement _if_statement_1) {
    assertPhylum(_if_statement_1, phylum_if_statement);
    statement kc_x = new impl_statement_IfStatement(_if_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IfStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IfStatement));
    kc_x->post_create();
    return static_cast<impl_statement_IfStatement*>(kc_x);
}

impl_statement_WhileStatement*
WhileStatement(while_statement _while_statement_1) {
    assertPhylum(_while_statement_1, phylum_while_statement);
    statement kc_x = new impl_statement_WhileStatement(_while_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_WhileStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_WhileStatement));
    kc_x->post_create();
    return static_cast<impl_statement_WhileStatement*>(kc_x);
}

impl_statement_RepeatStatement*
RepeatStatement(repeat_statement _repeat_statement_1) {
    assertPhylum(_repeat_statement_1, phylum_repeat_statement);
    statement kc_x = new impl_statement_RepeatStatement(_repeat_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_RepeatStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_RepeatStatement));
    kc_x->post_create();
    return static_cast<impl_statement_RepeatStatement*>(kc_x);
}

impl_statement_ForStatement*
ForStatement(for_statement _for_statement_1) {
    assertPhylum(_for_statement_1, phylum_for_statement);
    statement kc_x = new impl_statement_ForStatement(_for_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ForStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ForStatement));
    kc_x->post_create();
    return static_cast<impl_statement_ForStatement*>(kc_x);
}

impl_empty_statement_Empty*
Empty() {
    empty_statement kc_x = new impl_empty_statement_Empty();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Empty));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Empty));
    kc_x->post_create();
    return static_cast<impl_empty_statement_Empty*>(kc_x);
}

impl_assignment_statement_Assignment*
Assignment(variable_designator _variable_designator_1, expression _expression_1) {
    assertPhylum(_variable_designator_1, phylum_variable_designator);
    assertPhylum(_expression_1, phylum_expression);
    assignment_statement kc_x = new impl_assignment_statement_Assignment(_variable_designator_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Assignment));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Assignment));
    kc_x->post_create();
    return static_cast<impl_assignment_statement_Assignment*>(kc_x);
}

impl_function_call_FunctionCall*
FunctionCall(casestring _casestring_1, expression_list _expression_list_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_list_1, phylum_expression_list);
    function_call kc_x = new impl_function_call_FunctionCall(_casestring_1, _expression_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionCall));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionCall));
    kc_x->post_create();
    return static_cast<impl_function_call_FunctionCall*>(kc_x);
}

impl_return_statement_Return*
Return(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    return_statement kc_x = new impl_return_statement_Return(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Return));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Return));
    kc_x->post_create();
    return static_cast<impl_return_statement_Return*>(kc_x);
}

impl_if_statement_If*
If(expression _expression_1, statement_sequence _statement_sequence_1, elsif_list _elsif_list_1, opt_else _opt_else_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    assertPhylum(_elsif_list_1, phylum_elsif_list);
    assertPhylum(_opt_else_1, phylum_opt_else);
    if_statement kc_x = new impl_if_statement_If(_expression_1, _statement_sequence_1, _elsif_list_1, _opt_else_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_If));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_If));
    kc_x->post_create();
    return static_cast<impl_if_statement_If*>(kc_x);
}

impl_elsif_list*
Nilelsif_list() {
    elsif_list kc_x = new impl_elsif_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilelsif_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilelsif_list));
    kc_x->post_create();
    return static_cast<impl_elsif_list*>(kc_x);
}

impl_elsif_list*
Conselsif_list(elsif _elsif_1, elsif_list _elsif_list_1) {
    assertPhylum(_elsif_1, phylum_elsif);
    assertPhylum(_elsif_list_1, phylum_elsif_list);
    elsif_list kc_x = new impl_elsif_list(_elsif_1, _elsif_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Conselsif_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Conselsif_list));
    kc_x->post_create();
    return static_cast<impl_elsif_list*>(kc_x);
}

impl_elsif_Elsif*
Elsif(expression _expression_1, statement_sequence _statement_sequence_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    elsif kc_x = new impl_elsif_Elsif(_expression_1, _statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Elsif));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Elsif));
    kc_x->post_create();
    return static_cast<impl_elsif_Elsif*>(kc_x);
}

impl_opt_else_NoElse*
NoElse() {
    opt_else kc_x = new impl_opt_else_NoElse();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoElse));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoElse));
    kc_x->post_create();
    return static_cast<impl_opt_else_NoElse*>(kc_x);
}

impl_opt_else_Else*
Else(statement_sequence _statement_sequence_1) {
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    opt_else kc_x = new impl_opt_else_Else(_statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Else));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Else));
    kc_x->post_create();
    return static_cast<impl_opt_else_Else*>(kc_x);
}

impl_while_statement_While*
While(expression _expression_1, statement_sequence _statement_sequence_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    while_statement kc_x = new impl_while_statement_While(_expression_1, _statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_While));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_While));
    kc_x->post_create();
    return static_cast<impl_while_statement_While*>(kc_x);
}

impl_repeat_statement_Repeat*
Repeat(statement_sequence _statement_sequence_1, expression _expression_1) {
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    assertPhylum(_expression_1, phylum_expression);
    repeat_statement kc_x = new impl_repeat_statement_Repeat(_statement_sequence_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Repeat));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Repeat));
    kc_x->post_create();
    return static_cast<impl_repeat_statement_Repeat*>(kc_x);
}

impl_for_statement_For*
For(variable_designator _variable_designator_1, expression _expression_1, expression _expression_2, statement_sequence _statement_sequence_1) {
    assertPhylum(_variable_designator_1, phylum_variable_designator);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    for_statement kc_x = new impl_for_statement_For(_variable_designator_1, _expression_1, _expression_2, _statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_For));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_For));
    kc_x->post_create();
    return static_cast<impl_for_statement_For*>(kc_x);
}

impl_expression_list*
Nilexpression_list() {
    expression_list kc_x = new impl_expression_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilexpression_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilexpression_list));
    kc_x->post_create();
    return static_cast<impl_expression_list*>(kc_x);
}

impl_expression_list*
Consexpression_list(expression _expression_1, expression_list _expression_list_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_list_1, phylum_expression_list);
    expression_list kc_x = new impl_expression_list(_expression_1, _expression_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consexpression_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consexpression_list));
    kc_x->post_create();
    return static_cast<impl_expression_list*>(kc_x);
}

impl_statement_sequence*
Nilstatement_sequence() {
    statement_sequence kc_x = new impl_statement_sequence();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Nilstatement_sequence));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Nilstatement_sequence));
    kc_x->post_create();
    return static_cast<impl_statement_sequence*>(kc_x);
}

impl_statement_sequence*
Consstatement_sequence(statement _statement_1, statement_sequence _statement_sequence_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_statement_sequence_1, phylum_statement_sequence);
    statement_sequence kc_x = new impl_statement_sequence(_statement_1, _statement_sequence_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Consstatement_sequence));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Consstatement_sequence));
    kc_x->post_create();
    return static_cast<impl_statement_sequence*>(kc_x);
}

impl_expression_Not*
Not(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_Not(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Not));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Not));
    kc_x->post_create();
    return static_cast<impl_expression_Not*>(kc_x);
}

impl_expression_ExVariableDesignator*
ExVariableDesignator(variable_designator _variable_designator_1) {
    assertPhylum(_variable_designator_1, phylum_variable_designator);
    expression kc_x = new impl_expression_ExVariableDesignator(_variable_designator_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExVariableDesignator));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExVariableDesignator));
    kc_x->post_create();
    return static_cast<impl_expression_ExVariableDesignator*>(kc_x);
}

impl_expression_ExFunctionCall*
ExFunctionCall(function_call _function_call_1) {
    assertPhylum(_function_call_1, phylum_function_call);
    expression kc_x = new impl_expression_ExFunctionCall(_function_call_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExFunctionCall));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExFunctionCall));
    kc_x->post_create();
    return static_cast<impl_expression_ExFunctionCall*>(kc_x);
}

impl_expression_ConstantLiteral*
ConstantLiteral(constant_literal _constant_literal_1) {
    assertPhylum(_constant_literal_1, phylum_constant_literal);
    expression kc_x = new impl_expression_ConstantLiteral(_constant_literal_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstantLiteral));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstantLiteral));
    kc_x->post_create();
    return static_cast<impl_expression_ConstantLiteral*>(kc_x);
}

impl_expression_Eq*
Eq(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Eq(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Eq));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Eq));
    kc_x->post_create();
    return static_cast<impl_expression_Eq*>(kc_x);
}

impl_expression_Ne*
Ne(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Ne(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Ne));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Ne));
    kc_x->post_create();
    return static_cast<impl_expression_Ne*>(kc_x);
}

impl_expression_Le*
Le(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Le(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Le));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Le));
    kc_x->post_create();
    return static_cast<impl_expression_Le*>(kc_x);
}

impl_expression_Ge*
Ge(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Ge(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Ge));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Ge));
    kc_x->post_create();
    return static_cast<impl_expression_Ge*>(kc_x);
}

impl_expression_Leq*
Leq(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Leq(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Leq));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Leq));
    kc_x->post_create();
    return static_cast<impl_expression_Leq*>(kc_x);
}

impl_expression_Geq*
Geq(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Geq(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Geq));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Geq));
    kc_x->post_create();
    return static_cast<impl_expression_Geq*>(kc_x);
}

impl_expression_Plus*
Plus(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Plus(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Plus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Plus));
    kc_x->post_create();
    return static_cast<impl_expression_Plus*>(kc_x);
}

impl_expression_Minus*
Minus(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Minus(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Minus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Minus));
    kc_x->post_create();
    return static_cast<impl_expression_Minus*>(kc_x);
}

impl_expression_Or*
Or(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Or(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Or));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Or));
    kc_x->post_create();
    return static_cast<impl_expression_Or*>(kc_x);
}

impl_expression_Asterisk*
Asterisk(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Asterisk(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Asterisk));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Asterisk));
    kc_x->post_create();
    return static_cast<impl_expression_Asterisk*>(kc_x);
}

impl_expression_Slash*
Slash(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Slash(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Slash));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Slash));
    kc_x->post_create();
    return static_cast<impl_expression_Slash*>(kc_x);
}

impl_expression_Div*
Div(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Div(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Div));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Div));
    kc_x->post_create();
    return static_cast<impl_expression_Div*>(kc_x);
}

impl_expression_Mod*
Mod(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_Mod(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Mod));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Mod));
    kc_x->post_create();
    return static_cast<impl_expression_Mod*>(kc_x);
}

impl_expression_And*
And(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    expression kc_x = new impl_expression_And(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_And));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_And));
    kc_x->post_create();
    return static_cast<impl_expression_And*>(kc_x);
}

impl_constant_literal_IntegerConstant*
IntegerConstant(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    constant_literal kc_x = new impl_constant_literal_IntegerConstant(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IntegerConstant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IntegerConstant));
    kc_x->post_create();
    return static_cast<impl_constant_literal_IntegerConstant*>(kc_x);
}

impl_constant_literal_RealConstant*
RealConstant(real _real_1) {
    assertPhylum(_real_1, phylum_real);
    constant_literal kc_x = new impl_constant_literal_RealConstant(_real_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_RealConstant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_RealConstant));
    kc_x->post_create();
    return static_cast<impl_constant_literal_RealConstant*>(kc_x);
}

impl_constant_literal_CharConstant*
CharConstant(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    constant_literal kc_x = new impl_constant_literal_CharConstant(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_CharConstant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_CharConstant));
    kc_x->post_create();
    return static_cast<impl_constant_literal_CharConstant*>(kc_x);
}

impl_constant_literal_StringConstant*
StringConstant(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    constant_literal kc_x = new impl_constant_literal_StringConstant(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StringConstant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StringConstant));
    kc_x->post_create();
    return static_cast<impl_constant_literal_StringConstant*>(kc_x);
}


abstract_phylum
kc_create(enum_operators createOp, abstract_phylum kc_p1, abstract_phylum kc_p2, abstract_phylum kc_p3, abstract_phylum kc_p4)
{
    switch(createOp) {
    case sel__VoidPtr:
    case sel__Int:
    case sel__Real:
    case sel__Str:
    case sel_NoCaseStr:
	assertionFailed("Cannot create this kind of phylum - predefined phyla must be handled seperately");break;
    case sel_StringConstant:
	return StringConstant(phylum_cast<casestring>(kc_p1));
    case sel_CharConstant:
	return CharConstant(phylum_cast<casestring>(kc_p1));
    case sel_RealConstant:
	return RealConstant(phylum_cast<real>(kc_p1));
    case sel_IntegerConstant:
	return IntegerConstant(phylum_cast<integer>(kc_p1));
    case sel_And:
	return And(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Mod:
	return Mod(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Div:
	return Div(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Slash:
	return Slash(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Asterisk:
	return Asterisk(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Or:
	return Or(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Minus:
	return Minus(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Plus:
	return Plus(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Geq:
	return Geq(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Leq:
	return Leq(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Ge:
	return Ge(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Le:
	return Le(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Ne:
	return Ne(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Eq:
	return Eq(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ConstantLiteral:
	return ConstantLiteral(phylum_cast<constant_literal>(kc_p1));
    case sel_ExFunctionCall:
	return ExFunctionCall(phylum_cast<function_call>(kc_p1));
    case sel_ExVariableDesignator:
	return ExVariableDesignator(phylum_cast<variable_designator>(kc_p1));
    case sel_Not:
	return Not(phylum_cast<expression>(kc_p1));
    case sel_Consstatement_sequence:
	return Consstatement_sequence(phylum_cast<statement>(kc_p1), phylum_cast<statement_sequence>(kc_p2));
    case sel_Nilstatement_sequence:
	return Nilstatement_sequence();
    case sel_Consexpression_list:
	return Consexpression_list(phylum_cast<expression>(kc_p1), phylum_cast<expression_list>(kc_p2));
    case sel_Nilexpression_list:
	return Nilexpression_list();
    case sel_For:
	return For(phylum_cast<variable_designator>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3), phylum_cast<statement_sequence>(kc_p4));
    case sel_Repeat:
	return Repeat(phylum_cast<statement_sequence>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_While:
	return While(phylum_cast<expression>(kc_p1), phylum_cast<statement_sequence>(kc_p2));
    case sel_Else:
	return Else(phylum_cast<statement_sequence>(kc_p1));
    case sel_NoElse:
	return NoElse();
    case sel_Elsif:
	return Elsif(phylum_cast<expression>(kc_p1), phylum_cast<statement_sequence>(kc_p2));
    case sel_Conselsif_list:
	return Conselsif_list(phylum_cast<elsif>(kc_p1), phylum_cast<elsif_list>(kc_p2));
    case sel_Nilelsif_list:
	return Nilelsif_list();
    case sel_If:
	return If(phylum_cast<expression>(kc_p1), phylum_cast<statement_sequence>(kc_p2), phylum_cast<elsif_list>(kc_p3), phylum_cast<opt_else>(kc_p4));
    case sel_Return:
	return Return(phylum_cast<expression>(kc_p1));
    case sel_FunctionCall:
	return FunctionCall(phylum_cast<casestring>(kc_p1), phylum_cast<expression_list>(kc_p2));
    case sel_Assignment:
	return Assignment(phylum_cast<variable_designator>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Empty:
	return Empty();
    case sel_ForStatement:
	return ForStatement(phylum_cast<for_statement>(kc_p1));
    case sel_RepeatStatement:
	return RepeatStatement(phylum_cast<repeat_statement>(kc_p1));
    case sel_WhileStatement:
	return WhileStatement(phylum_cast<while_statement>(kc_p1));
    case sel_IfStatement:
	return IfStatement(phylum_cast<if_statement>(kc_p1));
    case sel_ReturnStatement:
	return ReturnStatement(phylum_cast<return_statement>(kc_p1));
    case sel_FunctionCallStatement:
	return FunctionCallStatement(phylum_cast<function_call>(kc_p1));
    case sel_AssignmentStatement:
	return AssignmentStatement(phylum_cast<assignment_statement>(kc_p1));
    case sel_EmptyStatement:
	return EmptyStatement(phylum_cast<empty_statement>(kc_p1));
    case sel_Subrange:
	return Subrange(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_TypeArray:
	return TypeArray(phylum_cast<subrange>(kc_p1), phylum_cast<type_denoter>(kc_p2));
    case sel_TypeChar:
	return TypeChar();
    case sel_TypeReal:
	return TypeReal();
    case sel_TypeInteger:
	return TypeInteger();
    case sel_TypeIdent:
	return TypeIdent(phylum_cast<casestring>(kc_p1));
    case sel_IndexedVariableDesignator:
	return IndexedVariableDesignator(phylum_cast<variable_designator>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_VariableDesignator:
	return VariableDesignator(phylum_cast<casestring>(kc_p1));
    case sel_Parameter:
	return Parameter(phylum_cast<casestring>(kc_p1), phylum_cast<type_denoter>(kc_p2));
    case sel_Consparameter_list:
	return Consparameter_list(phylum_cast<parameter>(kc_p1), phylum_cast<parameter_list>(kc_p2));
    case sel_Nilparameter_list:
	return Nilparameter_list();
    case sel_Procedure:
	return Procedure(phylum_cast<casestring>(kc_p1), phylum_cast<parameter_list>(kc_p2), phylum_cast<type_denoter>(kc_p3), phylum_cast<block>(kc_p4));
    case sel_VariableDeclaration:
	return VariableDeclaration(phylum_cast<casestring>(kc_p1), phylum_cast<type_denoter>(kc_p2));
    case sel_Consvariable_declaration_list:
	return Consvariable_declaration_list(phylum_cast<variable_declaration>(kc_p1), phylum_cast<variable_declaration_list>(kc_p2));
    case sel_Nilvariable_declaration_list:
	return Nilvariable_declaration_list();
    case sel_TypeDeclaration:
	return TypeDeclaration(phylum_cast<casestring>(kc_p1), phylum_cast<type_denoter>(kc_p2));
    case sel_Constype_declaration_list:
	return Constype_declaration_list(phylum_cast<type_declaration>(kc_p1), phylum_cast<type_declaration_list>(kc_p2));
    case sel_Niltype_declaration_list:
	return Niltype_declaration_list();
    case sel_ConstantDeclaration:
	return ConstantDeclaration(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_Consconstant_declaration_list:
	return Consconstant_declaration_list(phylum_cast<constant_declaration>(kc_p1), phylum_cast<constant_declaration_list>(kc_p2));
    case sel_Nilconstant_declaration_list:
	return Nilconstant_declaration_list();
    case sel_ProcedureDeclaration:
	return ProcedureDeclaration(phylum_cast<procedure_declaration>(kc_p1));
    case sel_VariableDeclarationList:
	return VariableDeclarationList(phylum_cast<variable_declaration_list>(kc_p1));
    case sel_TypeDeclarationList:
	return TypeDeclarationList(phylum_cast<type_declaration_list>(kc_p1));
    case sel_ConstantDeclarationList:
	return ConstantDeclarationList(phylum_cast<constant_declaration_list>(kc_p1));
    case sel_Consdeclaration_list:
	return Consdeclaration_list(phylum_cast<declaration>(kc_p1), phylum_cast<declaration_list>(kc_p2));
    case sel_Nildeclaration_list:
	return Nildeclaration_list();
    case sel_Block:
	return Block(phylum_cast<declaration_list>(kc_p1), phylum_cast<statement_sequence>(kc_p2));
    case sel_Module:
	return Module(phylum_cast<casestring>(kc_p1), phylum_cast<block>(kc_p2));
    default:
	assertionFailed("Cannot create this kind of phylum - unkown operator id");
    }
    NORETURN
}

abstract_phylum
kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps)
{
    if (kc_ps.size() < 4) {
	assertionFailed("Need vector of size of maximum subphylum count (which is 4)!");
    }
    return kc_create(createOp, kc_ps[0], kc_ps[1], kc_ps[2], kc_ps[3]);
}

abstract_phylum&
attributeOf(abstract_phylum kc_p, int no)
{
    assertionFailed("Cannot select attribute for this kind of phylum - has no attributes");
    NORETURN
}

abstract_phylum
impl_abstract_phylum::subphylum(int) const
{
    return 0;
}

void
impl_abstract_phylum::set_subphylum(int,abstract_phylum)
{
}

void
impl_abstract_phylum::free(bool kc_rec)
{
    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));
    if (!phylum_info[phylum()].uniq_stored) {
	if (kc_rec) {
	    abstract_phylum son;
	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)
	    {
		if (son!=0) son->free(kc_rec);
		son=0;
	    }
	}
	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));
	delete this;
    }
}

bool
impl_abstract_phylum::eq(c_abstract_phylum kc_p2) const
{
    if (this == kc_p2)
	return true;
    if (prod_sel() != kc_p2->prod_sel())
	return false;

    int kc_st = phylum_info[phylum()].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return false;

    c_abstract_phylum son1;
    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {
	if (!son1->eq(kc_p2->subphylum(kc_i)))
	    return false;
    }

    return true;
}

static string kc_indentation = "";
static const char *kc_printformat_not_nullary_open = "%s%s(\n";
static const char *kc_printformat_list_open = "%s%s\n";

static const char *kc_printformat_not_nullary_close = "%s)\n";
static const char *kc_printformat_nullary = "%s%s()\n";

void
impl_abstract_phylum::fprint(FILE*kc_f)
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    abstract_list al = dynamic_cast<abstract_list>(this);
    if (al != 0 && !al->is_nil()) {
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
    } else // not list
	switch(phylum()) {
	case phylum_voidptr:
	    fprintf(kc_f, "%s%p\n", kc_indentation.c_str(), static_cast<voidptr>(this)->pointer);
	    break;
	case phylum_casestring:
	case phylum_nocasestring:
	    fprintf(kc_f, "%s%s\n", kc_indentation.c_str(), static_cast<casestring>(this)->name);
	    break;
	case phylum_integer:
	    fprintf(kc_f, "%s%i\n", kc_indentation.c_str(), static_cast<integer>(this)->value);
	    break;
	case phylum_real:
	    fprintf(kc_f, "%s%f\n", kc_indentation.c_str(), static_cast<real>(this)->value);
	    break;
	default:
	    if (!subphylum(0)) {
		fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
	    } else {
		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());
		kc_indentation+="  ";
		abstract_phylum son;
		for (kc_i=0; (son = subphylum(kc_i)); kc_i++) {
		    son->fprint(kc_f);
		}
		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
		fprintf(kc_f, kc_printformat_not_nullary_close, kc_indentation.c_str());
	    }
    }
}

void 
impl_abstract_phylum::print()
{
    fprint(stdout);
}

void 
impl_abstract_list::fprint_list(FILE*kc_f)
{
    if (!kc_f)
	kc_f = stdout;
    if (this->is_nil()) {
	kc_indentation+="`-";
	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
    } else {
	kc_indentation+="|-";
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
    }
}

int
impl_abstract_list::length() const
{
    int kc_length = 0;
    c_abstract_phylum kc_p = this;
    while((kc_p = kc_p->subphylum(1)))
	kc_length++;
    return kc_length;
}
void impl_abstract_list::freelist()
{
    abstract_phylum kc_p = this, kc_tmp_p;
    do {
	kc_tmp_p=kc_p->subphylum(1);
	kc_p->free(false);
	kc_p=kc_tmp_p;
    } while(kc_p);
}
abstract_phylum
impl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const
{
    abstract_phylum next = subphylum(1);
    if(!next)
	return const_cast<abstract_phylum>(kc_p2);
    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));
}

abstract_phylum
impl_abstract_list::do_reverse(c_abstract_phylum tail, enum_operators mk) const
{
    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;
	iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )
    tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));
    return const_cast<abstract_phylum>(tail);
}

abstract_phylum
impl_abstract_list::last() const
{
    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;
#ifdef _AFX
    ASSERT(next);
    if(!next)
	return NULL;
#else
    if(!next){
	fflush(stdout);
	fprintf(stderr, "Internal Error: list::last was called with argument Nil%s\n", phylum_name());
	exit(1);
    }
#endif
    while ((nextnext = next->subphylum(1))) {
	kc_p = next;
	next = nextnext;
    }
    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */
}

abstract_phylum
impl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_create(mk, kc_fp(el), next->do_map(kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    if ((*kc_fp)(el)) {
	return kc_create(mk, el, next->do_filter(kc_fp, mk));
    } else {
	return next->do_filter(kc_fp, mk);
    }
}

abstract_list
impl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)
{
    abstract_list next = this;
    while (!next->is_nil())
	next = phylum_cast<abstract_list>(next->subphylum(1));
    next->set_subphylum(0, new_last);
    next->set_subphylum(1, eol);
    return next;
}

abstract_phylum
impl_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_phylum el2 = second->subphylum(0);
    if (!el2)
	return el2;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    abstract_list next2 = static_cast<abstract_list>(second->subphylum(1));
    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_reduce(abstract_phylum neutral, abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {
    abstract_phylum el = subphylum(0);
    if (!el)
	return neutral;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_fp(el,next->do_reduce(neutral,kc_fp));
}


extern const char* kc_storageclassnames[];

#ifdef KC_STATISTICS
void do_print_operator_statistics(FILE * kc_f)
{
    unsigned int kc_i;
    assertNonNull( kc_f );
    fprintf(kc_f, "%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\n", 38 , "Operator", 3, "Sz", 8, "#oper", 8, "#new", 8, "#exist", 8, "#frnrec", 8, "#frrec", 8, "#freed", 8, "#rem", 9, "total (bytes)");
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case sensitive strings", 3, "-", 8, operator_statistics[sel__Str].created, 8, operator_statistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case insensitive strings", 3, "-", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_found, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);
    for (kc_i = one_before_first_operator+1; kc_i < last_operator; kc_i++) {
	fprintf(kc_f, "%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].created, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));
    }
}
#endif // KC_STATISTICS


void
ht_static(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_static();
}

void
ht_dynamic(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dynamic();
}

void
ht_inc_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_inc_level();
}

void
ht_dec_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dec_level();
}

void
ht_free_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_free_level();
}

hashtable_t
ht_create_simple()
{
    hashtable_t kc_ht=new hashtable_struct_t;
    kc_ht->set_to_be_freed();
    return kc_ht;
}

hashtable_t
ht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)
{
    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];
    hashtables[kc_a_storageclass_t] = kc_a_hashtable_t;
    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;
    return kc_tmp;
}

hashtable_t
ht_assigned(kc_storageclass_t kc_a_storageclass_t)
{
    return hashtables[kc_a_storageclass_t];
}

void
ht_clear(hashtable_t kc_a_hashtable_t)
{
    kc_a_hashtable_t->ht_clear();
}

void
ht_delete(hashtable_t kc_a_hashtable_t)
{
    if(kc_a_hashtable_t->to_be_freed())
	delete kc_a_hashtable_t;
}
const char*
phylumname_or_error(enum_phyla kc_phy)
{
    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[69]), "Internal Error: unknown phylum number: %d", kc_phy);
	return kc_strof_error;
    } else {
	return phylum_info[kc_phy].name;
    }   }


const char*
kc_operatorname_or_error(enum_operators kc_operator)
{
    if ((kc_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[71]), "Internal Error: unknown operator number: %d", kc_operator);
	return kc_strof_error;
    } else {
	return operator_info[kc_operator].name;
    }   }


#ifndef KC_PRINTDOT_LABELSIZE
# define KC_PRINTDOT_LABELSIZE 1023
#endif

class impl_kc_dotedgenode_t
{
    public:
    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phylum to, int _son_nr):
    ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }
    c_abstract_phylum ptr_from;
    c_abstract_phylum ptr_to;
    int son_nr;
    char *label;
    int lsize;
    kc_dotedgenode_t next;
};

static kc_dotedgenode_t
kc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);
static void kc_do_printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);
static void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const char*, bool, bool);
static void kc_do_printdot_subgraph_epilogue (FILE*);
static void kc_do_printdot_genfields (FILE*, int, bool);
static void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const char*, bool);

static bool
kc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)
{
    if(p2==0)
	return false;
    if(p1==0)
	return true;
    if(p1->ptr_from<p2->ptr_from)
	return true;
    if(p1->ptr_from>p2->ptr_from)
	return false;
    if(p1->ptr_to<p2->ptr_to)
	return true;
    if(p1->ptr_to>p2->ptr_to)
	return false;
    if(p1->son_nr<p2->son_nr)
	return true;
    // OPERATORHASH((unsigned) kc_phy_from);
    // OPERATORHASH((unsigned) kc_phy_to);
    return false;
}

template<typename T>
struct dotedge_less : std::binary_function<T, T, bool> {
    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }
};

struct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less<kc_dotedgenode_t> > {
    ~kc_dotedge_ht() {
	for(iterator i=begin();i!=end();++i)
	delete const_cast<kc_dotedgenode_t>(*i);
	clear();
    }
    kc_dotedgenode_t check_insert(kc_dotedgenode_t t) {
	std::pair<iterator,bool> res=insert(t);
	return *res.first;
    }
};

static kc_dotedge_ht* fprintdot_hashtable;
void impl_nocasestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_casestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_real::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_integer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_voidptr::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_module::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_block::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declaration_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_constant_declaration_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_constant_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_type_declaration_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_type_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_variable_declaration_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_variable_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_procedure_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_parameter_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_parameter::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_variable_designator::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_type_denoter::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_subrange::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_empty_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_assignment_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_function_call::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_return_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_if_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_elsif_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_elsif::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_opt_else::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_while_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_repeat_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_for_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expression_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_statement_sequence::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expression::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_constant_literal::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}


kc_dotedgenode_t
kc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)
{
    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t(kc_s_from,kc_s_to,kc_son_nr);
    kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    }
    return kc_x;
}

void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "/*subgraph*/ {\n");
    if (root_label_prefix) {
	fprintf(kc_f, "\"%s\" [shape=ellipse", root_label_prefix);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	if (print_node_labels) {
	    fprintf(kc_f, ", label=\"%s\\n%s\"", root_label_prefix, phylum_info[kc_p->phylum()].name);
	}
	fprintf(kc_f, "];\n");
	fprintf(kc_f, "\"%s\" ->", root_label_prefix);
	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, "[%s]", edge_attributes);
	}
	fprintf(kc_f, ";\n");
    }
}

void kc_do_printdot_subgraph_epilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void fprintdotprologue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "digraph kc_output{\n");
    fprintf(kc_f, "node [shape=record, height=.1, fontname=Helvetica];\n");
}

void fprintdotepilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)
{
    int kc_i = 1;
    KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];
    if (kc_op_info->no_sons <= 0) return;
    if (!kc_f) kc_f = stdout;
    while(kc_i < kc_op_info->no_sons) {
	fprintf(kc_f, "<f%d>", kc_i);
	if (print_node_labels) {
	    fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
	}
	fprintf(kc_f, "|");
	kc_i++;
    }
    fprintf(kc_f, "<f%d>", kc_i);
    if (print_node_labels) {
	fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
    }
}

void impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    // The casts only make unique ids, so reinterpret_cast is alright
    if (!kc_f) kc_f = stdout;
    enum_phyla kc_phy = phylum();
    if (kc_phy == phylum_voidptr) {
	fprintf(kc_f, "kcidp%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {
	fprintf(kc_f, "kcids%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_integer) {
	fprintf(kc_f, "kcidi%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_real) {
	fprintf(kc_f, "kcidf%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else {
	fprintf(kc_f, "kcidx%x", reinterpret_cast<size_t>(this));
    }   }

void kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)
{
    kc_dotedgenode_t kc_hn;
    char kc_buf[30];
    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);
    if (! kc_hn->label) {
	kc_hn->label = new char[(size_t)(KC_PRINTDOT_LABELSIZE+1)];
	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;
	strcpy(kc_hn->label, "");
	kc_hn->next = *kc_edges;
	*kc_edges = kc_hn;
    } else {
	char kc_buf2[30];
	sprintf(kc_buf2, ", ");
	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));
    }
    if (edge_label_prefix) {
	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->label));
    }
    sprintf(kc_buf, "%d", *kc_edge_nr);
    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));
    (*kc_edge_nr)++;
}

void impl_abstract_phylum::printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const
{
    kc_do_printdot_do_add_edge(this, kc_sub_p, kc_son_nr, kc_edge_nr, kc_edges, edge_label_prefix);
}

void kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)
{
    kc_dotedgenode_t kc_p = kc_edges;
    if (!kc_f) kc_f = stdout;
    while(kc_p) {
	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	fprintf(kc_f, ":f%d -> ", kc_p->son_nr);
	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);
	fprintf(kc_f, " [label=\"%s\"", kc_p->label);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	fprintf(kc_f, "];\n");
	kc_p = kc_p->next;
    }   }

void impl_abstract_phylum::do_printdot(FILE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    switch(phylum()) {
	case phylum_voidptr:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%p\", shape=ellipse];\n", dynamic_cast<c_voidptr>(this)->pointer);
	break;
	case phylum_casestring:
	case phylum_nocasestring:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
#ifdef KC_UNICODE
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", kc_to_cstring(static_cast<c_casestring>(this)->name).c_str());
#else
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", static_cast<c_casestring>(this)->name);
#endif
	break;
	case phylum_integer:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%i\", shape=ellipse];\n", ((integer)this)->value);
	break;
	case phylum_real:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%f\", shape=ellipse];\n", ((real)this)->value);
	break;
	default:
	if (!subphylum(0)) {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"<f0>%s\"];\n", op_name());
	} else {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"{<f0>%s|{", op_name());
	    kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);
	    fprintf(kc_f, "}}\"];\n");
	    abstract_phylum child;
	    for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {
		printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );
		child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );
	    }
	}
    }
}
declaration_list
concat(c_declaration_list kc_p1, c_declaration_list kc_p2)
{ return dynamic_cast<declaration_list>(kc_p1->do_concat(kc_p2, sel_Consdeclaration_list)); }

declaration_list
impl_declaration_list::reverse() const
{ return dynamic_cast<declaration_list>(do_reverse(Nildeclaration_list(), sel_Consdeclaration_list)); }

declaration
impl_declaration_list::last() const
{ return dynamic_cast<declaration>(impl_abstract_list::last()); }

bool
impl_declaration_list::is_nil() const
{
    return declaration_1==0 && declaration_list_1==0;
}

declaration_list
impl_declaration_list::map(declaration (*kc_fp)(declaration))
{ return dynamic_cast<declaration_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consdeclaration_list)); }
declaration_list
impl_declaration_list::filter(bool (*kc_fp)(declaration))
{ return dynamic_cast<declaration_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consdeclaration_list)); }

declaration_list
impl_declaration_list::append(declaration new_last)
{
    return dynamic_cast<declaration_list>(do_append(new_last, Nildeclaration_list()));
}
declaration_list
impl_declaration_list::merge( declaration_list second, declaration (*kc_fp)(declaration, declaration))
{
    return dynamic_cast<declaration_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consdeclaration_list));
}
declaration
impl_declaration_list::reduce( declaration neutral, declaration (*kc_fp)(declaration, declaration))
{
    return dynamic_cast<declaration>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

constant_declaration_list
concat(c_constant_declaration_list kc_p1, c_constant_declaration_list kc_p2)
{ return dynamic_cast<constant_declaration_list>(kc_p1->do_concat(kc_p2, sel_Consconstant_declaration_list)); }

constant_declaration_list
impl_constant_declaration_list::reverse() const
{ return dynamic_cast<constant_declaration_list>(do_reverse(Nilconstant_declaration_list(), sel_Consconstant_declaration_list)); }

constant_declaration
impl_constant_declaration_list::last() const
{ return dynamic_cast<constant_declaration>(impl_abstract_list::last()); }

bool
impl_constant_declaration_list::is_nil() const
{
    return constant_declaration_1==0 && constant_declaration_list_1==0;
}

constant_declaration_list
impl_constant_declaration_list::map(constant_declaration (*kc_fp)(constant_declaration))
{ return dynamic_cast<constant_declaration_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consconstant_declaration_list)); }
constant_declaration_list
impl_constant_declaration_list::filter(bool (*kc_fp)(constant_declaration))
{ return dynamic_cast<constant_declaration_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consconstant_declaration_list)); }

constant_declaration_list
impl_constant_declaration_list::append(constant_declaration new_last)
{
    return dynamic_cast<constant_declaration_list>(do_append(new_last, Nilconstant_declaration_list()));
}
constant_declaration_list
impl_constant_declaration_list::merge( constant_declaration_list second, constant_declaration (*kc_fp)(constant_declaration, constant_declaration))
{
    return dynamic_cast<constant_declaration_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consconstant_declaration_list));
}
constant_declaration
impl_constant_declaration_list::reduce( constant_declaration neutral, constant_declaration (*kc_fp)(constant_declaration, constant_declaration))
{
    return dynamic_cast<constant_declaration>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

type_declaration_list
concat(c_type_declaration_list kc_p1, c_type_declaration_list kc_p2)
{ return dynamic_cast<type_declaration_list>(kc_p1->do_concat(kc_p2, sel_Constype_declaration_list)); }

type_declaration_list
impl_type_declaration_list::reverse() const
{ return dynamic_cast<type_declaration_list>(do_reverse(Niltype_declaration_list(), sel_Constype_declaration_list)); }

type_declaration
impl_type_declaration_list::last() const
{ return dynamic_cast<type_declaration>(impl_abstract_list::last()); }

bool
impl_type_declaration_list::is_nil() const
{
    return type_declaration_1==0 && type_declaration_list_1==0;
}

type_declaration_list
impl_type_declaration_list::map(type_declaration (*kc_fp)(type_declaration))
{ return dynamic_cast<type_declaration_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Constype_declaration_list)); }
type_declaration_list
impl_type_declaration_list::filter(bool (*kc_fp)(type_declaration))
{ return dynamic_cast<type_declaration_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Constype_declaration_list)); }

type_declaration_list
impl_type_declaration_list::append(type_declaration new_last)
{
    return dynamic_cast<type_declaration_list>(do_append(new_last, Niltype_declaration_list()));
}
type_declaration_list
impl_type_declaration_list::merge( type_declaration_list second, type_declaration (*kc_fp)(type_declaration, type_declaration))
{
    return dynamic_cast<type_declaration_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Constype_declaration_list));
}
type_declaration
impl_type_declaration_list::reduce( type_declaration neutral, type_declaration (*kc_fp)(type_declaration, type_declaration))
{
    return dynamic_cast<type_declaration>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

variable_declaration_list
concat(c_variable_declaration_list kc_p1, c_variable_declaration_list kc_p2)
{ return dynamic_cast<variable_declaration_list>(kc_p1->do_concat(kc_p2, sel_Consvariable_declaration_list)); }

variable_declaration_list
impl_variable_declaration_list::reverse() const
{ return dynamic_cast<variable_declaration_list>(do_reverse(Nilvariable_declaration_list(), sel_Consvariable_declaration_list)); }

variable_declaration
impl_variable_declaration_list::last() const
{ return dynamic_cast<variable_declaration>(impl_abstract_list::last()); }

bool
impl_variable_declaration_list::is_nil() const
{
    return variable_declaration_1==0 && variable_declaration_list_1==0;
}

variable_declaration_list
impl_variable_declaration_list::map(variable_declaration (*kc_fp)(variable_declaration))
{ return dynamic_cast<variable_declaration_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consvariable_declaration_list)); }
variable_declaration_list
impl_variable_declaration_list::filter(bool (*kc_fp)(variable_declaration))
{ return dynamic_cast<variable_declaration_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consvariable_declaration_list)); }

variable_declaration_list
impl_variable_declaration_list::append(variable_declaration new_last)
{
    return dynamic_cast<variable_declaration_list>(do_append(new_last, Nilvariable_declaration_list()));
}
variable_declaration_list
impl_variable_declaration_list::merge( variable_declaration_list second, variable_declaration (*kc_fp)(variable_declaration, variable_declaration))
{
    return dynamic_cast<variable_declaration_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consvariable_declaration_list));
}
variable_declaration
impl_variable_declaration_list::reduce( variable_declaration neutral, variable_declaration (*kc_fp)(variable_declaration, variable_declaration))
{
    return dynamic_cast<variable_declaration>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

parameter_list
concat(c_parameter_list kc_p1, c_parameter_list kc_p2)
{ return dynamic_cast<parameter_list>(kc_p1->do_concat(kc_p2, sel_Consparameter_list)); }

parameter_list
impl_parameter_list::reverse() const
{ return dynamic_cast<parameter_list>(do_reverse(Nilparameter_list(), sel_Consparameter_list)); }

parameter
impl_parameter_list::last() const
{ return dynamic_cast<parameter>(impl_abstract_list::last()); }

bool
impl_parameter_list::is_nil() const
{
    return parameter_1==0 && parameter_list_1==0;
}

parameter_list
impl_parameter_list::map(parameter (*kc_fp)(parameter))
{ return dynamic_cast<parameter_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consparameter_list)); }
parameter_list
impl_parameter_list::filter(bool (*kc_fp)(parameter))
{ return dynamic_cast<parameter_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consparameter_list)); }

parameter_list
impl_parameter_list::append(parameter new_last)
{
    return dynamic_cast<parameter_list>(do_append(new_last, Nilparameter_list()));
}
parameter_list
impl_parameter_list::merge( parameter_list second, parameter (*kc_fp)(parameter, parameter))
{
    return dynamic_cast<parameter_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consparameter_list));
}
parameter
impl_parameter_list::reduce( parameter neutral, parameter (*kc_fp)(parameter, parameter))
{
    return dynamic_cast<parameter>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

elsif_list
concat(c_elsif_list kc_p1, c_elsif_list kc_p2)
{ return dynamic_cast<elsif_list>(kc_p1->do_concat(kc_p2, sel_Conselsif_list)); }

elsif_list
impl_elsif_list::reverse() const
{ return dynamic_cast<elsif_list>(do_reverse(Nilelsif_list(), sel_Conselsif_list)); }

elsif
impl_elsif_list::last() const
{ return dynamic_cast<elsif>(impl_abstract_list::last()); }

bool
impl_elsif_list::is_nil() const
{
    return elsif_1==0 && elsif_list_1==0;
}

elsif_list
impl_elsif_list::map(elsif (*kc_fp)(elsif))
{ return dynamic_cast<elsif_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Conselsif_list)); }
elsif_list
impl_elsif_list::filter(bool (*kc_fp)(elsif))
{ return dynamic_cast<elsif_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Conselsif_list)); }

elsif_list
impl_elsif_list::append(elsif new_last)
{
    return dynamic_cast<elsif_list>(do_append(new_last, Nilelsif_list()));
}
elsif_list
impl_elsif_list::merge( elsif_list second, elsif (*kc_fp)(elsif, elsif))
{
    return dynamic_cast<elsif_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Conselsif_list));
}
elsif
impl_elsif_list::reduce( elsif neutral, elsif (*kc_fp)(elsif, elsif))
{
    return dynamic_cast<elsif>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

expression_list
concat(c_expression_list kc_p1, c_expression_list kc_p2)
{ return dynamic_cast<expression_list>(kc_p1->do_concat(kc_p2, sel_Consexpression_list)); }

expression_list
impl_expression_list::reverse() const
{ return dynamic_cast<expression_list>(do_reverse(Nilexpression_list(), sel_Consexpression_list)); }

expression
impl_expression_list::last() const
{ return dynamic_cast<expression>(impl_abstract_list::last()); }

bool
impl_expression_list::is_nil() const
{
    return expression_1==0 && expression_list_1==0;
}

expression_list
impl_expression_list::map(expression (*kc_fp)(expression))
{ return dynamic_cast<expression_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consexpression_list)); }
expression_list
impl_expression_list::filter(bool (*kc_fp)(expression))
{ return dynamic_cast<expression_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consexpression_list)); }

expression_list
impl_expression_list::append(expression new_last)
{
    return dynamic_cast<expression_list>(do_append(new_last, Nilexpression_list()));
}
expression_list
impl_expression_list::merge( expression_list second, expression (*kc_fp)(expression, expression))
{
    return dynamic_cast<expression_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consexpression_list));
}
expression
impl_expression_list::reduce( expression neutral, expression (*kc_fp)(expression, expression))
{
    return dynamic_cast<expression>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

statement_sequence
concat(c_statement_sequence kc_p1, c_statement_sequence kc_p2)
{ return dynamic_cast<statement_sequence>(kc_p1->do_concat(kc_p2, sel_Consstatement_sequence)); }

statement_sequence
impl_statement_sequence::reverse() const
{ return dynamic_cast<statement_sequence>(do_reverse(Nilstatement_sequence(), sel_Consstatement_sequence)); }

statement
impl_statement_sequence::last() const
{ return dynamic_cast<statement>(impl_abstract_list::last()); }

bool
impl_statement_sequence::is_nil() const
{
    return statement_1==0 && statement_sequence_1==0;
}

statement_sequence
impl_statement_sequence::map(statement (*kc_fp)(statement))
{ return dynamic_cast<statement_sequence>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_Consstatement_sequence)); }
statement_sequence
impl_statement_sequence::filter(bool (*kc_fp)(statement))
{ return dynamic_cast<statement_sequence>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_Consstatement_sequence)); }

statement_sequence
impl_statement_sequence::append(statement new_last)
{
    return dynamic_cast<statement_sequence>(do_append(new_last, Nilstatement_sequence()));
}
statement_sequence
impl_statement_sequence::merge( statement_sequence second, statement (*kc_fp)(statement, statement))
{
    return dynamic_cast<statement_sequence>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_Consstatement_sequence));
}
statement
impl_statement_sequence::reduce( statement neutral, statement (*kc_fp)(statement, statement))
{
    return dynamic_cast<statement>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

abstract_phylum
impl_abstract_phylum::copy(bool kc_copy_attributes) const
{
    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL
    KC_OPERATOR_INFO *kc_op_info = &operator_info[prod_sel()];
    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return const_cast<abstract_phylum>(this);
    abstract_phylum kc_answer=0;
    if (kc_phy == phylum_casestring) {
	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);
    } else if (kc_phy == phylum_nocasestring) {
	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);
    } else if (kc_phy == phylum_voidptr) {
	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);
    } else if (kc_phy == phylum_integer) {
	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);
    } else if (kc_phy == phylum_real) {
	kc_answer=mkreal((dynamic_cast<c_real>(this))->value);
    } else {
	abstract_phylum kc_subtmp[4], child;
	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {
	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);
	}
	switch(kc_op_info->no_sons) {
	    case 0: kc_answer = kc_create(prod_sel()); break;
	    case 1: kc_answer = kc_create(prod_sel(), kc_subtmp[0]); break;
	    case 2: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1]); break;
	    case 4: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3]); break;
	    default: assertionFailed("unexpected number of sub-phyla");
	}
    }
    if (kc_copy_attributes)
	copy_attributes(kc_phy, this, kc_answer);
    return kc_answer;
}


} // namespace kc
