/* translation of file(s)
	"abstract.k"
	"unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#ifndef KC_TYPES_HEADER
#define KC_TYPES_HEADER

#define KIMWITUVERSIONMAJOR 2
#define KIMWITUVERSIONMINOR 3
#define KIMWITUVERSIONMICRO 13

#include <stdio.h>
#include <stddef.h>
#include <string>
#include <vector>

namespace kc {

#ifndef INTEGER
# define INTEGER int
#endif
#ifndef REAL
# define REAL double
#endif

#ifdef KC_UNICODE

#define kc_t(TEXT) L ## TEXT
typedef wchar_t kc_char_t;
typedef std::wstring kc_string_t;

#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strlen wcslen
#define kc_strcmp wcscmp
#define kc_strcasecmp _wcsicmp
#define kc_strcpy wcscpy
#define kc_strncpy wcsncpy
#define kc_tolower towlower
#define kc_print_integer(buf,number) swprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) swprintf(buf,kc_t("%g"),number)

// needed for printdot and csgio only
inline
std::string kc_to_cstring(const std::wstring& s) {
    USES_CONVERSION;
    return W2CA(s.c_str());
}

// needed for csgio only
inline
std::wstring kc_to_wstring(const std::string& s) {
    USES_CONVERSION;
    return A2CW(s.c_str());
}

#else // !defined(_WIN32) || defined(__GNUC__)
// if you want to use UNICODE on other platforms you have to write
// the following functions on your own
int kc_strlen(const kc_char_t*);
int kc_strcmp(const kc_char_t*,const kc_char_t*);
int kc_strcasecmp(const kc_char_t*,const kc_char_t*);
int kc_strcpy(kc_char_t*,const kc_char_t*);
int kc_strncpy(kc_char_t*,const kc_char_t*, int);
kc_char_t kc_tolower(kc_char_t);
int kc_print_integer(kc_char_t* buffer, INTEGER number );
int kc_print_real(kc_char_t* buffer, REAL number);

// needed for printdot and csgio only
std::string kc_to_cstring(const std::wstring& );
// needed for csgio only
std::wstring kc_to_wstring(const std::string& );

#endif

#else // !KC_UNICODE

#define kc_t(TEXT) TEXT  
typedef char kc_char_t;
typedef std::string kc_string_t;

#define kc_strlen strlen
#define kc_strcmp strcmp
#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strcasecmp _stricmp
#else
#define kc_strcasecmp strcasecmp
#endif
#define kc_strcpy strcpy
#define kc_strncpy strncpy
#define kc_tolower tolower  
#define kc_print_integer(buf,number) sprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) sprintf(buf,kc_t("%g"),number)
#endif
class uview_class;
typedef uview_class& uview;
typedef const uview_class& c_uview;

typedef class printer_functor_class& printer_functor;
typedef void (*printer_function)(const kc_char_t*, uview);

class rview_class;
typedef rview_class& rview;
typedef const rview_class& c_rview;

}

// Some compilers know __attribute__. Right now we test for the GNU compiler
// and Intel's icc (for ia32) and ecc (for ia64).
#if !defined __GNUC__ && !defined __ICC && !defined __ECC
# define __attribute__(x)
#endif

// Since all definitions are in namespace kc now, there is no need
// give them a kc_ prefix. Old code may still rely on the prefix, so these
// macros are generated for backwards compatibility
#ifdef KC_DEPRECATED
#define kc_PhylumInfo           phylum_info
#define kc_OperatorInfo         operator_info
#define kc_last_uview           last_uview
#define kc_uviews               uviews
#define kc_rviews               rviews
#define kc_ht_reuse             ht_clear
#define kc_ht_clear             ht_clear
#define kc_ht_assign            ht_assign
#define kc_ht_assigned          ht_assigned
#define kc_phylum_nocasestring phylum_nocasestring
#define kc_tag_nocasestring_NoCaseStr impl_nocasestring_NoCaseStr
#define kc_phylum_casestring phylum_casestring
#define kc_tag_casestring__Str impl_casestring__Str
#define kc_phylum_real phylum_real
#define kc_tag_real__Real impl_real__Real
#define kc_phylum_integer phylum_integer
#define kc_tag_integer__Int impl_integer__Int
#define kc_phylum_voidptr phylum_voidptr
#define kc_tag_voidptr__VoidPtr impl_voidptr__VoidPtr
#define kc_phylum_module phylum_module
#define kc_tag_module_Module impl_module_Module
#define kc_phylum_block phylum_block
#define kc_tag_block_Block impl_block_Block
#define kc_phylum_declaration_list phylum_declaration_list
#define kc_tag_declaration_list_Nildeclaration_list impl_declaration_list_Nildeclaration_list
#define kc_tag_declaration_list_Consdeclaration_list impl_declaration_list_Consdeclaration_list
#define kc_phylum_declaration phylum_declaration
#define kc_tag_declaration_ConstantDeclarationList impl_declaration_ConstantDeclarationList
#define kc_tag_declaration_TypeDeclarationList impl_declaration_TypeDeclarationList
#define kc_tag_declaration_VariableDeclarationList impl_declaration_VariableDeclarationList
#define kc_tag_declaration_ProcedureDeclaration impl_declaration_ProcedureDeclaration
#define kc_phylum_constant_declaration_list phylum_constant_declaration_list
#define kc_tag_constant_declaration_list_Nilconstant_declaration_list impl_constant_declaration_list_Nilconstant_declaration_list
#define kc_tag_constant_declaration_list_Consconstant_declaration_list impl_constant_declaration_list_Consconstant_declaration_list
#define kc_phylum_constant_declaration phylum_constant_declaration
#define kc_tag_constant_declaration_ConstantDeclaration impl_constant_declaration_ConstantDeclaration
#define kc_phylum_type_declaration_list phylum_type_declaration_list
#define kc_tag_type_declaration_list_Niltype_declaration_list impl_type_declaration_list_Niltype_declaration_list
#define kc_tag_type_declaration_list_Constype_declaration_list impl_type_declaration_list_Constype_declaration_list
#define kc_phylum_type_declaration phylum_type_declaration
#define kc_tag_type_declaration_TypeDeclaration impl_type_declaration_TypeDeclaration
#define kc_phylum_variable_declaration_list phylum_variable_declaration_list
#define kc_tag_variable_declaration_list_Nilvariable_declaration_list impl_variable_declaration_list_Nilvariable_declaration_list
#define kc_tag_variable_declaration_list_Consvariable_declaration_list impl_variable_declaration_list_Consvariable_declaration_list
#define kc_phylum_variable_declaration phylum_variable_declaration
#define kc_tag_variable_declaration_VariableDeclaration impl_variable_declaration_VariableDeclaration
#define kc_phylum_procedure_declaration phylum_procedure_declaration
#define kc_tag_procedure_declaration_Procedure impl_procedure_declaration_Procedure
#define kc_phylum_parameter_list phylum_parameter_list
#define kc_tag_parameter_list_Nilparameter_list impl_parameter_list_Nilparameter_list
#define kc_tag_parameter_list_Consparameter_list impl_parameter_list_Consparameter_list
#define kc_phylum_parameter phylum_parameter
#define kc_tag_parameter_Parameter impl_parameter_Parameter
#define kc_phylum_variable_designator phylum_variable_designator
#define kc_tag_variable_designator_VariableDesignator impl_variable_designator_VariableDesignator
#define kc_tag_variable_designator_IndexedVariableDesignator impl_variable_designator_IndexedVariableDesignator
#define kc_phylum_type_denoter phylum_type_denoter
#define kc_tag_type_denoter_TypeIdent impl_type_denoter_TypeIdent
#define kc_tag_type_denoter_TypeInteger impl_type_denoter_TypeInteger
#define kc_tag_type_denoter_TypeReal impl_type_denoter_TypeReal
#define kc_tag_type_denoter_TypeChar impl_type_denoter_TypeChar
#define kc_tag_type_denoter_TypeArray impl_type_denoter_TypeArray
#define kc_phylum_subrange phylum_subrange
#define kc_tag_subrange_Subrange impl_subrange_Subrange
#define kc_phylum_statement phylum_statement
#define kc_tag_statement_EmptyStatement impl_statement_EmptyStatement
#define kc_tag_statement_AssignmentStatement impl_statement_AssignmentStatement
#define kc_tag_statement_FunctionCallStatement impl_statement_FunctionCallStatement
#define kc_tag_statement_ReturnStatement impl_statement_ReturnStatement
#define kc_tag_statement_IfStatement impl_statement_IfStatement
#define kc_tag_statement_WhileStatement impl_statement_WhileStatement
#define kc_tag_statement_RepeatStatement impl_statement_RepeatStatement
#define kc_tag_statement_ForStatement impl_statement_ForStatement
#define kc_phylum_empty_statement phylum_empty_statement
#define kc_tag_empty_statement_Empty impl_empty_statement_Empty
#define kc_phylum_assignment_statement phylum_assignment_statement
#define kc_tag_assignment_statement_Assignment impl_assignment_statement_Assignment
#define kc_phylum_function_call phylum_function_call
#define kc_tag_function_call_FunctionCall impl_function_call_FunctionCall
#define kc_phylum_return_statement phylum_return_statement
#define kc_tag_return_statement_Return impl_return_statement_Return
#define kc_phylum_if_statement phylum_if_statement
#define kc_tag_if_statement_If impl_if_statement_If
#define kc_phylum_elsif_list phylum_elsif_list
#define kc_tag_elsif_list_Nilelsif_list impl_elsif_list_Nilelsif_list
#define kc_tag_elsif_list_Conselsif_list impl_elsif_list_Conselsif_list
#define kc_phylum_elsif phylum_elsif
#define kc_tag_elsif_Elsif impl_elsif_Elsif
#define kc_phylum_opt_else phylum_opt_else
#define kc_tag_opt_else_NoElse impl_opt_else_NoElse
#define kc_tag_opt_else_Else impl_opt_else_Else
#define kc_phylum_while_statement phylum_while_statement
#define kc_tag_while_statement_While impl_while_statement_While
#define kc_phylum_repeat_statement phylum_repeat_statement
#define kc_tag_repeat_statement_Repeat impl_repeat_statement_Repeat
#define kc_phylum_for_statement phylum_for_statement
#define kc_tag_for_statement_For impl_for_statement_For
#define kc_phylum_expression_list phylum_expression_list
#define kc_tag_expression_list_Nilexpression_list impl_expression_list_Nilexpression_list
#define kc_tag_expression_list_Consexpression_list impl_expression_list_Consexpression_list
#define kc_phylum_statement_sequence phylum_statement_sequence
#define kc_tag_statement_sequence_Nilstatement_sequence impl_statement_sequence_Nilstatement_sequence
#define kc_tag_statement_sequence_Consstatement_sequence impl_statement_sequence_Consstatement_sequence
#define kc_phylum_expression phylum_expression
#define kc_tag_expression_Not impl_expression_Not
#define kc_tag_expression_ExVariableDesignator impl_expression_ExVariableDesignator
#define kc_tag_expression_ExFunctionCall impl_expression_ExFunctionCall
#define kc_tag_expression_ConstantLiteral impl_expression_ConstantLiteral
#define kc_tag_expression_Eq impl_expression_Eq
#define kc_tag_expression_Ne impl_expression_Ne
#define kc_tag_expression_Le impl_expression_Le
#define kc_tag_expression_Ge impl_expression_Ge
#define kc_tag_expression_Leq impl_expression_Leq
#define kc_tag_expression_Geq impl_expression_Geq
#define kc_tag_expression_Plus impl_expression_Plus
#define kc_tag_expression_Minus impl_expression_Minus
#define kc_tag_expression_Or impl_expression_Or
#define kc_tag_expression_Asterisk impl_expression_Asterisk
#define kc_tag_expression_Slash impl_expression_Slash
#define kc_tag_expression_Div impl_expression_Div
#define kc_tag_expression_Mod impl_expression_Mod
#define kc_tag_expression_And impl_expression_And
#define kc_phylum_constant_literal phylum_constant_literal
#define kc_tag_constant_literal_IntegerConstant impl_constant_literal_IntegerConstant
#define kc_tag_constant_literal_RealConstant impl_constant_literal_RealConstant
#define kc_tag_constant_literal_CharConstant impl_constant_literal_CharConstant
#define kc_tag_constant_literal_StringConstant impl_constant_literal_StringConstant

#endif // KC_DEPRECATED

// Some compilers are too stupid to detect that a function will always return
// a proper value when it returns one in all branches of an if- or switch-
// statement (with final else or default, of course).
#if !defined __GNUC__
# define NORETURN throw 0;
#else
# define NORETURN
#endif

namespace kc {


typedef enum { one_before_first_phylum = 0 ,
    phylum_nocasestring = 1,
    phylum_casestring = 2,
    phylum_real = 3,
    phylum_integer = 4,
    phylum_voidptr = 5,
    phylum_module = 6,
    phylum_block = 7,
    phylum_declaration_list = 8,
    phylum_declaration = 9,
    phylum_constant_declaration_list = 10,
    phylum_constant_declaration = 11,
    phylum_type_declaration_list = 12,
    phylum_type_declaration = 13,
    phylum_variable_declaration_list = 14,
    phylum_variable_declaration = 15,
    phylum_procedure_declaration = 16,
    phylum_parameter_list = 17,
    phylum_parameter = 18,
    phylum_variable_designator = 19,
    phylum_type_denoter = 20,
    phylum_subrange = 21,
    phylum_statement = 22,
    phylum_empty_statement = 23,
    phylum_assignment_statement = 24,
    phylum_function_call = 25,
    phylum_return_statement = 26,
    phylum_if_statement = 27,
    phylum_elsif_list = 28,
    phylum_elsif = 29,
    phylum_opt_else = 30,
    phylum_while_statement = 31,
    phylum_repeat_statement = 32,
    phylum_for_statement = 33,
    phylum_expression_list = 34,
    phylum_statement_sequence = 35,
    phylum_expression = 36,
    phylum_constant_literal = 37,
    last_phylum = 38
} enum_phyla;

typedef enum { one_before_first_operator = 0 ,
    sel_NoCaseStr = 1,
    sel__Str = 2,
    sel__Real = 3,
    sel__Int = 4,
    sel__VoidPtr = 5,
    sel_Module = 6,
    sel_Block = 7,
    sel_Nildeclaration_list = 8,
    sel_Consdeclaration_list = 9,
    sel_ConstantDeclarationList = 10,
    sel_TypeDeclarationList = 11,
    sel_VariableDeclarationList = 12,
    sel_ProcedureDeclaration = 13,
    sel_Nilconstant_declaration_list = 14,
    sel_Consconstant_declaration_list = 15,
    sel_ConstantDeclaration = 16,
    sel_Niltype_declaration_list = 17,
    sel_Constype_declaration_list = 18,
    sel_TypeDeclaration = 19,
    sel_Nilvariable_declaration_list = 20,
    sel_Consvariable_declaration_list = 21,
    sel_VariableDeclaration = 22,
    sel_Procedure = 23,
    sel_Nilparameter_list = 24,
    sel_Consparameter_list = 25,
    sel_Parameter = 26,
    sel_VariableDesignator = 27,
    sel_IndexedVariableDesignator = 28,
    sel_TypeIdent = 29,
    sel_TypeInteger = 30,
    sel_TypeReal = 31,
    sel_TypeChar = 32,
    sel_TypeArray = 33,
    sel_Subrange = 34,
    sel_EmptyStatement = 35,
    sel_AssignmentStatement = 36,
    sel_FunctionCallStatement = 37,
    sel_ReturnStatement = 38,
    sel_IfStatement = 39,
    sel_WhileStatement = 40,
    sel_RepeatStatement = 41,
    sel_ForStatement = 42,
    sel_Empty = 43,
    sel_Assignment = 44,
    sel_FunctionCall = 45,
    sel_Return = 46,
    sel_If = 47,
    sel_Nilelsif_list = 48,
    sel_Conselsif_list = 49,
    sel_Elsif = 50,
    sel_NoElse = 51,
    sel_Else = 52,
    sel_While = 53,
    sel_Repeat = 54,
    sel_For = 55,
    sel_Nilexpression_list = 56,
    sel_Consexpression_list = 57,
    sel_Nilstatement_sequence = 58,
    sel_Consstatement_sequence = 59,
    sel_Not = 60,
    sel_ExVariableDesignator = 61,
    sel_ExFunctionCall = 62,
    sel_ConstantLiteral = 63,
    sel_Eq = 64,
    sel_Ne = 65,
    sel_Le = 66,
    sel_Ge = 67,
    sel_Leq = 68,
    sel_Geq = 69,
    sel_Plus = 70,
    sel_Minus = 71,
    sel_Or = 72,
    sel_Asterisk = 73,
    sel_Slash = 74,
    sel_Div = 75,
    sel_Mod = 76,
    sel_And = 77,
    sel_IntegerConstant = 78,
    sel_RealConstant = 79,
    sel_CharConstant = 80,
    sel_StringConstant = 81,
    last_operator = 82
} enum_operators;

class impl_abstract_phylum;
typedef impl_abstract_phylum * abstract_phylum;
typedef const impl_abstract_phylum * c_abstract_phylum;
class impl_abstract_list;
typedef impl_abstract_list * abstract_list;
typedef const impl_abstract_list * c_abstract_list;

template <typename P, typename T>
P phylum_cast(T* t) {
    return static_cast<P>(t);
}
template <typename P, typename T>
const P phylum_cast(const T* t) {
    return static_cast<const P>(t);
}
class impl_nocasestring_NoCaseStr;
class impl_casestring__Str;
class impl_real__Real;
class impl_integer__Int;
class impl_voidptr__VoidPtr;
class impl_module;
class impl_block;
class impl_declaration_list;
class impl_declaration;
class impl_constant_declaration_list;
class impl_constant_declaration;
class impl_type_declaration_list;
class impl_type_declaration;
class impl_variable_declaration_list;
class impl_variable_declaration;
class impl_procedure_declaration;
class impl_parameter_list;
class impl_parameter;
class impl_variable_designator;
class impl_type_denoter;
class impl_subrange;
class impl_statement;
class impl_empty_statement;
class impl_assignment_statement;
class impl_function_call;
class impl_return_statement;
class impl_if_statement;
class impl_elsif_list;
class impl_elsif;
class impl_opt_else;
class impl_while_statement;
class impl_repeat_statement;
class impl_for_statement;
class impl_expression_list;
class impl_statement_sequence;
class impl_expression;
class impl_constant_literal;


void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,
    const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));

typedef enum_phyla *enum_phyla_list;

/*
 * make sure that the first 'real' storage class _always_ gets a value > 0
 * and kc_not_uniq gets a value == 0
 * (because then we can use it as a C boolean)
 */
enum kc_storageclass_t {
    kc_not_uniq,
    uniq,
    last_storageclass
};

typedef struct {
    const char *name;			// name of the phylum
    enum_operators first_operator;	// index in operator_info[]
    enum_operators last_operator;	// index in operator_info[]
    kc_storageclass_t uniq_stored;	// storage class
} KC_PHYLUM_INFO;

typedef struct {
    const char *name;			// name of the operator
    size_t no_sons;			// number of sons
    bool atomicity;			// atomic type or not
    enum_phyla phylum;			// index in phylum_info[]
    enum_phyla_list subphylum;		// indexes in phylum_info[]
    int no_attrs;			// number of attributes
    enum_phyla_list attribute;		// indexes in phylum_info[]
    size_t size;			// size of operator (for statistics)
} KC_OPERATOR_INFO;

typedef enum_phyla_list KC_UNIQ_INFO;

extern KC_OPERATOR_INFO operator_info[];
extern KC_PHYLUM_INFO phylum_info[];
extern KC_UNIQ_INFO kc_UniqInfo[];

#define KC_OP_NAME(op) (operator_info[op].name)
#define KC_NO_SONS(prod) (operator_info[prod].no_sons)
#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)

typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;

typedef impl_nocasestring_NoCaseStr *nocasestring;
typedef const impl_nocasestring_NoCaseStr *c_nocasestring;
typedef impl_casestring__Str *casestring;
typedef const impl_casestring__Str *c_casestring;
typedef impl_real__Real *real;
typedef const impl_real__Real *c_real;
typedef impl_integer__Int *integer;
typedef const impl_integer__Int *c_integer;
typedef impl_voidptr__VoidPtr *voidptr;
typedef const impl_voidptr__VoidPtr *c_voidptr;
typedef impl_module *module;
typedef const impl_module *c_module;
typedef impl_block *block;
typedef const impl_block *c_block;
typedef impl_declaration_list *declaration_list;
typedef const impl_declaration_list *c_declaration_list;
typedef impl_declaration *declaration;
typedef const impl_declaration *c_declaration;
typedef impl_constant_declaration_list *constant_declaration_list;
typedef const impl_constant_declaration_list *c_constant_declaration_list;
typedef impl_constant_declaration *constant_declaration;
typedef const impl_constant_declaration *c_constant_declaration;
typedef impl_type_declaration_list *type_declaration_list;
typedef const impl_type_declaration_list *c_type_declaration_list;
typedef impl_type_declaration *type_declaration;
typedef const impl_type_declaration *c_type_declaration;
typedef impl_variable_declaration_list *variable_declaration_list;
typedef const impl_variable_declaration_list *c_variable_declaration_list;
typedef impl_variable_declaration *variable_declaration;
typedef const impl_variable_declaration *c_variable_declaration;
typedef impl_procedure_declaration *procedure_declaration;
typedef const impl_procedure_declaration *c_procedure_declaration;
typedef impl_parameter_list *parameter_list;
typedef const impl_parameter_list *c_parameter_list;
typedef impl_parameter *parameter;
typedef const impl_parameter *c_parameter;
typedef impl_variable_designator *variable_designator;
typedef const impl_variable_designator *c_variable_designator;
typedef impl_type_denoter *type_denoter;
typedef const impl_type_denoter *c_type_denoter;
typedef impl_subrange *subrange;
typedef const impl_subrange *c_subrange;
typedef impl_statement *statement;
typedef const impl_statement *c_statement;
typedef impl_empty_statement *empty_statement;
typedef const impl_empty_statement *c_empty_statement;
typedef impl_assignment_statement *assignment_statement;
typedef const impl_assignment_statement *c_assignment_statement;
typedef impl_function_call *function_call;
typedef const impl_function_call *c_function_call;
typedef impl_return_statement *return_statement;
typedef const impl_return_statement *c_return_statement;
typedef impl_if_statement *if_statement;
typedef const impl_if_statement *c_if_statement;
typedef impl_elsif_list *elsif_list;
typedef const impl_elsif_list *c_elsif_list;
typedef impl_elsif *elsif;
typedef const impl_elsif *c_elsif;
typedef impl_opt_else *opt_else;
typedef const impl_opt_else *c_opt_else;
typedef impl_while_statement *while_statement;
typedef const impl_while_statement *c_while_statement;
typedef impl_repeat_statement *repeat_statement;
typedef const impl_repeat_statement *c_repeat_statement;
typedef impl_for_statement *for_statement;
typedef const impl_for_statement *c_for_statement;
typedef impl_expression_list *expression_list;
typedef const impl_expression_list *c_expression_list;
typedef impl_statement_sequence *statement_sequence;
typedef const impl_statement_sequence *c_statement_sequence;
typedef impl_expression *expression;
typedef const impl_expression *c_expression;
typedef impl_constant_literal *constant_literal;
typedef const impl_constant_literal *c_constant_literal;

#define KC_NO_OF_OPERATORS 82


} // namespace kc

namespace kc {

#ifndef KC_NO_DEFAULT_IN_WITH
# define KC_NO_DEFAULT_IN_WITH "Internal Error: no default action defined in function %s at %s:%d\n"
#endif
void kc_no_default_in_with (const char*, int, const char*);
void kc_returnless_function (const char *, int, const char*);

#ifndef NDEBUG
# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)
# define assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)
# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false)
# define assertPhylum(ptr,phy) do { \
    assertNonNull(ptr); \
    if (ptr->phylum()!=phy) \
	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,"->prod_sel()","phy",__FILE__,__LINE__); \
} while(false)
#else
# define assertCond(t)
# define assertReason(t,s)
# define assertNonNull(ptr)
# define assertPhylum(op,phy)
#endif
#define assertionFailed(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)

void kc_assertionFailed (const char*, int) __attribute__ ((noreturn));
void kc_assertionReasonFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const char*, const char*, int) __attribute__ ((noreturn));

casestring mkcasestring( const kc_char_t *, int length = -1);
nocasestring mknocasestring( const kc_char_t *, int length = -1);
integer mkinteger( const INTEGER );
real mkreal( const REAL );
inline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }
inline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }
inline integer _Int( const INTEGER cc) { return mkinteger(cc); }
inline real _Real( const REAL cc) { return mkreal(cc); }
class impl_module_Module* Module (casestring, block);
class impl_block_Block* Block (declaration_list, statement_sequence);
declaration_list Nildeclaration_list();
declaration_list Consdeclaration_list(declaration,declaration_list);
class impl_declaration_ConstantDeclarationList* ConstantDeclarationList (constant_declaration_list);
class impl_declaration_TypeDeclarationList* TypeDeclarationList (type_declaration_list);
class impl_declaration_VariableDeclarationList* VariableDeclarationList (variable_declaration_list);
class impl_declaration_ProcedureDeclaration* ProcedureDeclaration (procedure_declaration);
constant_declaration_list Nilconstant_declaration_list();
constant_declaration_list Consconstant_declaration_list(constant_declaration,constant_declaration_list);
class impl_constant_declaration_ConstantDeclaration* ConstantDeclaration (casestring, expression);
type_declaration_list Niltype_declaration_list();
type_declaration_list Constype_declaration_list(type_declaration,type_declaration_list);
class impl_type_declaration_TypeDeclaration* TypeDeclaration (casestring, type_denoter);
variable_declaration_list Nilvariable_declaration_list();
variable_declaration_list Consvariable_declaration_list(variable_declaration,variable_declaration_list);
class impl_variable_declaration_VariableDeclaration* VariableDeclaration (casestring, type_denoter);
class impl_procedure_declaration_Procedure* Procedure (casestring, parameter_list, type_denoter, block);
parameter_list Nilparameter_list();
parameter_list Consparameter_list(parameter,parameter_list);
class impl_parameter_Parameter* Parameter (casestring, type_denoter);
class impl_variable_designator_VariableDesignator* VariableDesignator (casestring);
class impl_variable_designator_IndexedVariableDesignator* IndexedVariableDesignator (variable_designator, expression);
class impl_type_denoter_TypeIdent* TypeIdent (casestring);
class impl_type_denoter_TypeInteger* TypeInteger ();
class impl_type_denoter_TypeReal* TypeReal ();
class impl_type_denoter_TypeChar* TypeChar ();
class impl_type_denoter_TypeArray* TypeArray (subrange, type_denoter);
class impl_subrange_Subrange* Subrange (expression, expression);
class impl_statement_EmptyStatement* EmptyStatement (empty_statement);
class impl_statement_AssignmentStatement* AssignmentStatement (assignment_statement);
class impl_statement_FunctionCallStatement* FunctionCallStatement (function_call);
class impl_statement_ReturnStatement* ReturnStatement (return_statement);
class impl_statement_IfStatement* IfStatement (if_statement);
class impl_statement_WhileStatement* WhileStatement (while_statement);
class impl_statement_RepeatStatement* RepeatStatement (repeat_statement);
class impl_statement_ForStatement* ForStatement (for_statement);
class impl_empty_statement_Empty* Empty ();
class impl_assignment_statement_Assignment* Assignment (variable_designator, expression);
class impl_function_call_FunctionCall* FunctionCall (casestring, expression_list);
class impl_return_statement_Return* Return (expression);
class impl_if_statement_If* If (expression, statement_sequence, elsif_list, opt_else);
elsif_list Nilelsif_list();
elsif_list Conselsif_list(elsif,elsif_list);
class impl_elsif_Elsif* Elsif (expression, statement_sequence);
class impl_opt_else_NoElse* NoElse ();
class impl_opt_else_Else* Else (statement_sequence);
class impl_while_statement_While* While (expression, statement_sequence);
class impl_repeat_statement_Repeat* Repeat (statement_sequence, expression);
class impl_for_statement_For* For (variable_designator, expression, expression, statement_sequence);
expression_list Nilexpression_list();
expression_list Consexpression_list(expression,expression_list);
statement_sequence Nilstatement_sequence();
statement_sequence Consstatement_sequence(statement,statement_sequence);
class impl_expression_Not* Not (expression);
class impl_expression_ExVariableDesignator* ExVariableDesignator (variable_designator);
class impl_expression_ExFunctionCall* ExFunctionCall (function_call);
class impl_expression_ConstantLiteral* ConstantLiteral (constant_literal);
class impl_expression_Eq* Eq (expression, expression);
class impl_expression_Ne* Ne (expression, expression);
class impl_expression_Le* Le (expression, expression);
class impl_expression_Ge* Ge (expression, expression);
class impl_expression_Leq* Leq (expression, expression);
class impl_expression_Geq* Geq (expression, expression);
class impl_expression_Plus* Plus (expression, expression);
class impl_expression_Minus* Minus (expression, expression);
class impl_expression_Or* Or (expression, expression);
class impl_expression_Asterisk* Asterisk (expression, expression);
class impl_expression_Slash* Slash (expression, expression);
class impl_expression_Div* Div (expression, expression);
class impl_expression_Mod* Mod (expression, expression);
class impl_expression_And* And (expression, expression);
class impl_constant_literal_IntegerConstant* IntegerConstant (integer);
class impl_constant_literal_RealConstant* RealConstant (real);
class impl_constant_literal_CharConstant* CharConstant (casestring);
class impl_constant_literal_StringConstant* StringConstant (casestring);

//namespace Phylum {

class impl_abstract_phylum {
public:
    virtual enum_operators prod_sel() const =0;
    static const enum_phyla phylum_sel_;
    enum_phyla phylum() const;
    const char* phylum_name() const;
    const char* op_name() const;
    virtual abstract_phylum subphylum(int) const;
    virtual void set_subphylum(int, abstract_phylum);
    void free(bool recursive=true);
    bool eq(c_abstract_phylum) const;
    void print();
    void fprint(FILE *);
    abstract_phylum copy(bool kc_copy_attributes) const;
    void unparse(printer_functor pf, uview uv)
	{ do_unparse(pf, uv); }
    void unparse(printer_function opf, uview uv);

    void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;
    void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;
    void do_printdot (FILE*, bool, int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;

    virtual void fprintdot(FILE *,
	const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes,
	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;
    virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }
    virtual abstract_phylum do_rewrite(rview) { return this;}
    // called if a subphylum of an op is rewritten and a new op is created by default rule
    virtual void rewrite_members(abstract_phylum from) {} 
    virtual void post_create(){}
    virtual ~impl_abstract_phylum() { }
private:
    virtual void do_unparse(printer_functor, uview) =0;
protected:
    virtual void default_unparse(printer_functor, uview);
};


class impl_abstract_list: public impl_abstract_phylum{
private:
    void fprint_list(FILE *);
    friend class impl_abstract_phylum;
protected:
    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;
    abstract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;
    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);
    abstract_phylum do_filter(bool (*kc_fp)(abstract_phylum), enum_operators);
    abstract_list   do_append(abstract_phylum, abstract_list);
    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum), enum_operators);
    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));
public:
    virtual bool is_nil() const =0;
    virtual abstract_list reverse() const =0;
    int length() const;
    abstract_phylum last() const;
    // Non-virtual, non-existing... Type must be known exactly anyway because
    // of the function given as a parameter
    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;
    //virtual abstract_list filter(bool (*)(abstract_phylum)) =0;
    void freelist();
};

abstract_phylum kc_create(enum_operators createOp, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0);
abstract_phylum kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps);
abstract_phylum& attributeOf(abstract_phylum kc_p, int no);

class impl_nocasestring_NoCaseStr;
typedef impl_nocasestring_NoCaseStr impl_nocasestring;
class impl_nocasestring_NoCaseStr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel_NoCaseStr; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_nocasestring_NoCaseStr(const kc_char_t*);
    void make_own(int length);
    friend nocasestring mknocasestring(const kc_char_t*, int);
public:
    ~impl_nocasestring_NoCaseStr() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    nocasestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_casestring__Str;
typedef impl_casestring__Str impl_casestring;
class impl_casestring__Str:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Str; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_casestring__Str(const kc_char_t*);
    void make_own(int length);
    friend casestring mkcasestring(const kc_char_t*, int);
public:
    ~impl_casestring__Str() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    casestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_real__Real;
typedef impl_real__Real impl_real;
class impl_real__Real:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Real; }
    static const enum_phyla phylum_sel_;
    explicit impl_real__Real(REAL _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    real rewrite( rview )
	{ return this; }
    REAL value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_integer__Int;
typedef impl_integer__Int impl_integer;
class impl_integer__Int:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Int; }
    static const enum_phyla phylum_sel_;
    explicit impl_integer__Int(INTEGER _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    integer rewrite( rview )
	{ return this; }
    INTEGER value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_voidptr__VoidPtr;
typedef impl_voidptr__VoidPtr impl_voidptr;
class impl_voidptr__VoidPtr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__VoidPtr; }
    static const enum_phyla phylum_sel_;
    explicit impl_voidptr__VoidPtr(void* _pointer);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    voidptr rewrite( rview )
	{ return this; }
    void* pointer;
private:
    void do_unparse(printer_functor, uview);
};
class impl_module: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    module rewrite(rview) =0;
};
class impl_module_Module:public impl_module{
public:
    enum_operators prod_sel() const
	{ return sel_Module; }
    explicit impl_module_Module(casestring, block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    module rewrite( rview );
    impl_casestring* casestring_1;
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_block: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    block rewrite(rview) =0;
};
class impl_block_Block:public impl_block{
public:
    enum_operators prod_sel() const
	{ return sel_Block; }
    explicit impl_block_Block(declaration_list, statement_sequence);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    block rewrite( rview );
    impl_declaration_list* declaration_list_1;
    impl_statement_sequence* statement_sequence_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nildeclaration_list: sel_Consdeclaration_list;
    }
    explicit impl_declaration_list(declaration = 0, declaration_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend declaration_list concat(c_declaration_list, c_declaration_list);
    declaration_list reverse() const;
    declaration_list rewrite(rview);
    declaration last() const;
    declaration_list append(declaration);
    declaration_list map(declaration (*)(declaration));
    declaration_list filter( bool (*)(declaration));
    declaration_list merge( declaration_list, declaration (*)(declaration, declaration));
    declaration reduce( declaration, declaration (*)(declaration, declaration));
    bool is_nil() const;
    declaration declaration_1;
    declaration_list declaration_list_1;
private:
    impl_declaration_list* nil_rewrite(rview);
    impl_declaration_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    declaration rewrite(rview) =0;
};
class impl_declaration_ProcedureDeclaration:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_ProcedureDeclaration; }
    explicit impl_declaration_ProcedureDeclaration(procedure_declaration);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_procedure_declaration* procedure_declaration_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration_VariableDeclarationList:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_VariableDeclarationList; }
    explicit impl_declaration_VariableDeclarationList(variable_declaration_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_variable_declaration_list* variable_declaration_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration_TypeDeclarationList:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_TypeDeclarationList; }
    explicit impl_declaration_TypeDeclarationList(type_declaration_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_type_declaration_list* type_declaration_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration_ConstantDeclarationList:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_ConstantDeclarationList; }
    explicit impl_declaration_ConstantDeclarationList(constant_declaration_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_constant_declaration_list* constant_declaration_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant_declaration_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilconstant_declaration_list: sel_Consconstant_declaration_list;
    }
    explicit impl_constant_declaration_list(constant_declaration = 0, constant_declaration_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend constant_declaration_list concat(c_constant_declaration_list, c_constant_declaration_list);
    constant_declaration_list reverse() const;
    constant_declaration_list rewrite(rview);
    constant_declaration last() const;
    constant_declaration_list append(constant_declaration);
    constant_declaration_list map(constant_declaration (*)(constant_declaration));
    constant_declaration_list filter( bool (*)(constant_declaration));
    constant_declaration_list merge( constant_declaration_list, constant_declaration (*)(constant_declaration, constant_declaration));
    constant_declaration reduce( constant_declaration, constant_declaration (*)(constant_declaration, constant_declaration));
    bool is_nil() const;
    constant_declaration constant_declaration_1;
    constant_declaration_list constant_declaration_list_1;
private:
    impl_constant_declaration_list* nil_rewrite(rview);
    impl_constant_declaration_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_constant_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    constant_declaration rewrite(rview) =0;
};
class impl_constant_declaration_ConstantDeclaration:public impl_constant_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_ConstantDeclaration; }
    explicit impl_constant_declaration_ConstantDeclaration(casestring, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant_declaration rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_declaration_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Niltype_declaration_list: sel_Constype_declaration_list;
    }
    explicit impl_type_declaration_list(type_declaration = 0, type_declaration_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend type_declaration_list concat(c_type_declaration_list, c_type_declaration_list);
    type_declaration_list reverse() const;
    type_declaration_list rewrite(rview);
    type_declaration last() const;
    type_declaration_list append(type_declaration);
    type_declaration_list map(type_declaration (*)(type_declaration));
    type_declaration_list filter( bool (*)(type_declaration));
    type_declaration_list merge( type_declaration_list, type_declaration (*)(type_declaration, type_declaration));
    type_declaration reduce( type_declaration, type_declaration (*)(type_declaration, type_declaration));
    bool is_nil() const;
    type_declaration type_declaration_1;
    type_declaration_list type_declaration_list_1;
private:
    impl_type_declaration_list* nil_rewrite(rview);
    impl_type_declaration_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_type_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type_declaration rewrite(rview) =0;
};
class impl_type_declaration_TypeDeclaration:public impl_type_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_TypeDeclaration; }
    explicit impl_type_declaration_TypeDeclaration(casestring, type_denoter);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type_declaration rewrite( rview );
    impl_casestring* casestring_1;
    impl_type_denoter* type_denoter_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable_declaration_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilvariable_declaration_list: sel_Consvariable_declaration_list;
    }
    explicit impl_variable_declaration_list(variable_declaration = 0, variable_declaration_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend variable_declaration_list concat(c_variable_declaration_list, c_variable_declaration_list);
    variable_declaration_list reverse() const;
    variable_declaration_list rewrite(rview);
    variable_declaration last() const;
    variable_declaration_list append(variable_declaration);
    variable_declaration_list map(variable_declaration (*)(variable_declaration));
    variable_declaration_list filter( bool (*)(variable_declaration));
    variable_declaration_list merge( variable_declaration_list, variable_declaration (*)(variable_declaration, variable_declaration));
    variable_declaration reduce( variable_declaration, variable_declaration (*)(variable_declaration, variable_declaration));
    bool is_nil() const;
    variable_declaration variable_declaration_1;
    variable_declaration_list variable_declaration_list_1;
private:
    impl_variable_declaration_list* nil_rewrite(rview);
    impl_variable_declaration_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_variable_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    variable_declaration rewrite(rview) =0;
};
class impl_variable_declaration_VariableDeclaration:public impl_variable_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_VariableDeclaration; }
    explicit impl_variable_declaration_VariableDeclaration(casestring, type_denoter);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    variable_declaration rewrite( rview );
    impl_casestring* casestring_1;
    impl_type_denoter* type_denoter_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_procedure_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    procedure_declaration rewrite(rview) =0;
};
class impl_procedure_declaration_Procedure:public impl_procedure_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_Procedure; }
    explicit impl_procedure_declaration_Procedure(casestring, parameter_list, type_denoter, block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    procedure_declaration rewrite( rview );
    impl_casestring* casestring_1;
    impl_parameter_list* parameter_list_1;
    impl_type_denoter* type_denoter_1;
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_parameter_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilparameter_list: sel_Consparameter_list;
    }
    explicit impl_parameter_list(parameter = 0, parameter_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend parameter_list concat(c_parameter_list, c_parameter_list);
    parameter_list reverse() const;
    parameter_list rewrite(rview);
    parameter last() const;
    parameter_list append(parameter);
    parameter_list map(parameter (*)(parameter));
    parameter_list filter( bool (*)(parameter));
    parameter_list merge( parameter_list, parameter (*)(parameter, parameter));
    parameter reduce( parameter, parameter (*)(parameter, parameter));
    bool is_nil() const;
    parameter parameter_1;
    parameter_list parameter_list_1;
private:
    impl_parameter_list* nil_rewrite(rview);
    impl_parameter_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_parameter: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    parameter rewrite(rview) =0;
};
class impl_parameter_Parameter:public impl_parameter{
public:
    enum_operators prod_sel() const
	{ return sel_Parameter; }
    explicit impl_parameter_Parameter(casestring, type_denoter);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    parameter rewrite( rview );
    impl_casestring* casestring_1;
    impl_type_denoter* type_denoter_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable_designator: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    variable_designator rewrite(rview) =0;
};
class impl_variable_designator_IndexedVariableDesignator:public impl_variable_designator{
public:
    enum_operators prod_sel() const
	{ return sel_IndexedVariableDesignator; }
    explicit impl_variable_designator_IndexedVariableDesignator(variable_designator, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    variable_designator rewrite( rview );
    impl_variable_designator* variable_designator_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable_designator_VariableDesignator:public impl_variable_designator{
public:
    enum_operators prod_sel() const
	{ return sel_VariableDesignator; }
    explicit impl_variable_designator_VariableDesignator(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    variable_designator rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_denoter: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type_denoter rewrite(rview) =0;
};
class impl_type_denoter_TypeArray:public impl_type_denoter{
public:
    enum_operators prod_sel() const
	{ return sel_TypeArray; }
    explicit impl_type_denoter_TypeArray(subrange, type_denoter);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type_denoter rewrite( rview );
    impl_subrange* subrange_1;
    impl_type_denoter* type_denoter_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_denoter_TypeChar:public impl_type_denoter{
public:
    enum_operators prod_sel() const
	{ return sel_TypeChar; }
    explicit impl_type_denoter_TypeChar();

    type_denoter rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_denoter_TypeReal:public impl_type_denoter{
public:
    enum_operators prod_sel() const
	{ return sel_TypeReal; }
    explicit impl_type_denoter_TypeReal();

    type_denoter rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_denoter_TypeInteger:public impl_type_denoter{
public:
    enum_operators prod_sel() const
	{ return sel_TypeInteger; }
    explicit impl_type_denoter_TypeInteger();

    type_denoter rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_denoter_TypeIdent:public impl_type_denoter{
public:
    enum_operators prod_sel() const
	{ return sel_TypeIdent; }
    explicit impl_type_denoter_TypeIdent(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type_denoter rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_subrange: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    subrange rewrite(rview) =0;
};
class impl_subrange_Subrange:public impl_subrange{
public:
    enum_operators prod_sel() const
	{ return sel_Subrange; }
    explicit impl_subrange_Subrange(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    subrange rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    statement rewrite(rview) =0;
};
class impl_statement_ForStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_ForStatement; }
    explicit impl_statement_ForStatement(for_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_for_statement* for_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_RepeatStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_RepeatStatement; }
    explicit impl_statement_RepeatStatement(repeat_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_repeat_statement* repeat_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_WhileStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_WhileStatement; }
    explicit impl_statement_WhileStatement(while_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_while_statement* while_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_IfStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_IfStatement; }
    explicit impl_statement_IfStatement(if_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_if_statement* if_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_ReturnStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_ReturnStatement; }
    explicit impl_statement_ReturnStatement(return_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_return_statement* return_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_FunctionCallStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionCallStatement; }
    explicit impl_statement_FunctionCallStatement(function_call);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_function_call* function_call_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_AssignmentStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_AssignmentStatement; }
    explicit impl_statement_AssignmentStatement(assignment_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_assignment_statement* assignment_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_EmptyStatement:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyStatement; }
    explicit impl_statement_EmptyStatement(empty_statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_empty_statement* empty_statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_empty_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    empty_statement rewrite(rview) =0;
};
class impl_empty_statement_Empty:public impl_empty_statement{
public:
    enum_operators prod_sel() const
	{ return sel_Empty; }
    explicit impl_empty_statement_Empty();

    empty_statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    assignment_statement rewrite(rview) =0;
};
class impl_assignment_statement_Assignment:public impl_assignment_statement{
public:
    enum_operators prod_sel() const
	{ return sel_Assignment; }
    explicit impl_assignment_statement_Assignment(variable_designator, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment_statement rewrite( rview );
    impl_variable_designator* variable_designator_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_function_call: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    function_call rewrite(rview) =0;
};
class impl_function_call_FunctionCall:public impl_function_call{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionCall; }
    explicit impl_function_call_FunctionCall(casestring, expression_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    function_call rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression_list* expression_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_return_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    return_statement rewrite(rview) =0;
};
class impl_return_statement_Return:public impl_return_statement{
public:
    enum_operators prod_sel() const
	{ return sel_Return; }
    explicit impl_return_statement_Return(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    return_statement rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_if_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    if_statement rewrite(rview) =0;
};
class impl_if_statement_If:public impl_if_statement{
public:
    enum_operators prod_sel() const
	{ return sel_If; }
    explicit impl_if_statement_If(expression, statement_sequence, elsif_list, opt_else);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    if_statement rewrite( rview );
    impl_expression* expression_1;
    impl_statement_sequence* statement_sequence_1;
    impl_elsif_list* elsif_list_1;
    impl_opt_else* opt_else_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_elsif_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilelsif_list: sel_Conselsif_list;
    }
    explicit impl_elsif_list(elsif = 0, elsif_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend elsif_list concat(c_elsif_list, c_elsif_list);
    elsif_list reverse() const;
    elsif_list rewrite(rview);
    elsif last() const;
    elsif_list append(elsif);
    elsif_list map(elsif (*)(elsif));
    elsif_list filter( bool (*)(elsif));
    elsif_list merge( elsif_list, elsif (*)(elsif, elsif));
    elsif reduce( elsif, elsif (*)(elsif, elsif));
    bool is_nil() const;
    elsif elsif_1;
    elsif_list elsif_list_1;
private:
    impl_elsif_list* nil_rewrite(rview);
    impl_elsif_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_elsif: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    elsif rewrite(rview) =0;
};
class impl_elsif_Elsif:public impl_elsif{
public:
    enum_operators prod_sel() const
	{ return sel_Elsif; }
    explicit impl_elsif_Elsif(expression, statement_sequence);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    elsif rewrite( rview );
    impl_expression* expression_1;
    impl_statement_sequence* statement_sequence_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_opt_else: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    opt_else rewrite(rview) =0;
};
class impl_opt_else_Else:public impl_opt_else{
public:
    enum_operators prod_sel() const
	{ return sel_Else; }
    explicit impl_opt_else_Else(statement_sequence);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    opt_else rewrite( rview );
    impl_statement_sequence* statement_sequence_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_opt_else_NoElse:public impl_opt_else{
public:
    enum_operators prod_sel() const
	{ return sel_NoElse; }
    explicit impl_opt_else_NoElse();

    opt_else rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_while_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    while_statement rewrite(rview) =0;
};
class impl_while_statement_While:public impl_while_statement{
public:
    enum_operators prod_sel() const
	{ return sel_While; }
    explicit impl_while_statement_While(expression, statement_sequence);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    while_statement rewrite( rview );
    impl_expression* expression_1;
    impl_statement_sequence* statement_sequence_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_repeat_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    repeat_statement rewrite(rview) =0;
};
class impl_repeat_statement_Repeat:public impl_repeat_statement{
public:
    enum_operators prod_sel() const
	{ return sel_Repeat; }
    explicit impl_repeat_statement_Repeat(statement_sequence, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    repeat_statement rewrite( rview );
    impl_statement_sequence* statement_sequence_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_for_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    for_statement rewrite(rview) =0;
};
class impl_for_statement_For:public impl_for_statement{
public:
    enum_operators prod_sel() const
	{ return sel_For; }
    explicit impl_for_statement_For(variable_designator, expression, expression, statement_sequence);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    for_statement rewrite( rview );
    impl_variable_designator* variable_designator_1;
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_statement_sequence* statement_sequence_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilexpression_list: sel_Consexpression_list;
    }
    explicit impl_expression_list(expression = 0, expression_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend expression_list concat(c_expression_list, c_expression_list);
    expression_list reverse() const;
    expression_list rewrite(rview);
    expression last() const;
    expression_list append(expression);
    expression_list map(expression (*)(expression));
    expression_list filter( bool (*)(expression));
    expression_list merge( expression_list, expression (*)(expression, expression));
    expression reduce( expression, expression (*)(expression, expression));
    bool is_nil() const;
    expression expression_1;
    expression_list expression_list_1;
private:
    impl_expression_list* nil_rewrite(rview);
    impl_expression_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_statement_sequence: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_Nilstatement_sequence: sel_Consstatement_sequence;
    }
    explicit impl_statement_sequence(statement = 0, statement_sequence = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend statement_sequence concat(c_statement_sequence, c_statement_sequence);
    statement_sequence reverse() const;
    statement_sequence rewrite(rview);
    statement last() const;
    statement_sequence append(statement);
    statement_sequence map(statement (*)(statement));
    statement_sequence filter( bool (*)(statement));
    statement_sequence merge( statement_sequence, statement (*)(statement, statement));
    statement reduce( statement, statement (*)(statement, statement));
    bool is_nil() const;
    statement statement_1;
    statement_sequence statement_sequence_1;
private:
    impl_statement_sequence* nil_rewrite(rview);
    impl_statement_sequence* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_expression: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    expression rewrite(rview) =0;
};
class impl_expression_And:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_And; }
    explicit impl_expression_And(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Mod:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Mod; }
    explicit impl_expression_Mod(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Div:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Div; }
    explicit impl_expression_Div(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Slash:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Slash; }
    explicit impl_expression_Slash(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Asterisk:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Asterisk; }
    explicit impl_expression_Asterisk(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Or:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Or; }
    explicit impl_expression_Or(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Minus:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Minus; }
    explicit impl_expression_Minus(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Plus:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Plus; }
    explicit impl_expression_Plus(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Geq:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Geq; }
    explicit impl_expression_Geq(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Leq:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Leq; }
    explicit impl_expression_Leq(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Ge:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Ge; }
    explicit impl_expression_Ge(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Le:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Le; }
    explicit impl_expression_Le(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Ne:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Ne; }
    explicit impl_expression_Ne(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Eq:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Eq; }
    explicit impl_expression_Eq(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ConstantLiteral:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ConstantLiteral; }
    explicit impl_expression_ConstantLiteral(constant_literal);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_constant_literal* constant_literal_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExFunctionCall:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExFunctionCall; }
    explicit impl_expression_ExFunctionCall(function_call);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_function_call* function_call_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExVariableDesignator:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExVariableDesignator; }
    explicit impl_expression_ExVariableDesignator(variable_designator);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_variable_designator* variable_designator_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_Not:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_Not; }
    explicit impl_expression_Not(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant_literal: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    constant_literal rewrite(rview) =0;
};
class impl_constant_literal_StringConstant:public impl_constant_literal{
public:
    enum_operators prod_sel() const
	{ return sel_StringConstant; }
    explicit impl_constant_literal_StringConstant(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant_literal rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant_literal_CharConstant:public impl_constant_literal{
public:
    enum_operators prod_sel() const
	{ return sel_CharConstant; }
    explicit impl_constant_literal_CharConstant(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant_literal rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant_literal_RealConstant:public impl_constant_literal{
public:
    enum_operators prod_sel() const
	{ return sel_RealConstant; }
    explicit impl_constant_literal_RealConstant(real);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant_literal rewrite( rview );
    impl_real* real_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant_literal_IntegerConstant:public impl_constant_literal{
public:
    enum_operators prod_sel() const
	{ return sel_IntegerConstant; }
    explicit impl_constant_literal_IntegerConstant(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant_literal rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};

//} // namespace Phylum


extern bool kc_storageclass_still_uniq[];

typedef struct {
    int created;
    int existing_not_found;
    int free_called[2];
    int freed[2];
} KC_OPERATOR_STATISTICS;

#ifdef KC_STATISTICS
# define print_operator_statistics(kc_f) do_print_operator_statistics(kc_f)
void	do_print_operator_statistics(FILE*);
#else
# define print_operator_statistics(kc_f)
#endif

typedef class hashtable_struct_t* hashtable_t;
void	ht_static (kc_storageclass_t);
void	ht_dynamic (kc_storageclass_t);
void	ht_inc_level (kc_storageclass_t);
void	ht_dec_level (kc_storageclass_t);
void	ht_free_level (kc_storageclass_t);
hashtable_t	ht_create_simple ();
hashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);
hashtable_t	ht_assigned (kc_storageclass_t);
void	ht_clear (hashtable_t);
void	ht_delete (hashtable_t);
const char *phylumname_or_error ( enum_phyla );
const char *kc_operatorname_or_error ( enum_operators );


void fprintdotprologue ( FILE* );
void fprintdotepilogue ( FILE* );

} // namespace kc
#endif // KC_TYPES_HEADER
